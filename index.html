<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>VIEWR</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='logo.png') }}">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='logo.png') }}">
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <meta name="theme-color" content="#0a0a0a">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        /* Prevent text selection on interactive elements for mobile app-like feel */
        body, button, .upload-box, .history-item, .image-container, .edit-canvas-container,
        .output-image-area, .mobile-tabs, .panel-tab, .mode-btn, .input-mode-btn {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow text selection only in text inputs */
        textarea, input[type="text"] {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #0a0a0a;
            color: #e5e5e5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            padding: 16px 32px;
            border-bottom: 1px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }



        .logo span {
            font-size: 16px;
            font-weight: 500;
            letter-spacing: 0.4em;
            color: #fff;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .mode-toggle {
            display: flex;
            gap: 4px;
        }

        .mode-btn {
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 8px 16px;
            font-size: 12px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .mode-btn:hover:not(.active) {
            border-color: #555;
            color: #999;
        }

        .status {
            font-size: 9px;
            color: #333;
        }

        .status.connected {
            color: #4a4;
        }

        .status.disconnected {
            color: #a44;
        }

        .storage-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: #888;
            margin-left: 12px;
        }

        .storage-bar {
            width: 60px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .storage-fill {
            width: 0;
            height: 100%;
            background: #4a4;
            border-radius: 3px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .storage-fill.warning {
            background: #c90;
        }

        .storage-fill.critical {
            background: #c44;
        }

        .storage-text {
            min-width: 45px;
            text-align: right;
        }

        /* Main Layout */
        main {
            flex: 1;
            display: flex;
            height: calc(100vh - 53px);
            overflow: hidden;
        }

        /* Resizer */
        .resizer {
            width: 4px;
            cursor: col-resize;
            background: #1a1a1a;
            transition: background 0.2s;
            flex-shrink: 0;
            z-index: 10;
        }

        .resizer:hover,
        .resizer.resizing {
            background: #444;
        }

        /* Left Panel - Inputs */
        .inputs {
            width: 350px;
            min-width: 250px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .inputs-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        .inputs-content::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .upload-box {
            border: 1px dashed #333;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* 9/16 = 56.25% for 16:9 ratio */
            overflow: hidden;
        }

        .upload-box .upload-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-box:hover,
        .upload-box.dragover {
            border-color: #555;
            background: #111;
        }

        .upload-box.has-image {
            border-style: solid;
        }
        
        .upload-box.has-image .upload-content {
            display: none;
        }

        .upload-box img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-box .label {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            margin-bottom: 4px;
        }

        .upload-box .hint {
            font-size: 12px;
            color: #444;
        }

        .upload-box .clear-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #999;
            width: 24px;
            height: 24px;
            font-size: 18px;
            cursor: pointer;
            display: none;
            line-height: 1;
            z-index: 10;
        }

        .upload-box.has-image .clear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-box .clear-btn:hover {
            color: #fff;
            border-color: #666;
        }

        .upload-box.has-image .label,
        .upload-box.has-image .hint {
            display: none;
        }

        .upload-box input[type="file"] {
            display: none;
        }

        /* Multi-Reference Container - Fixed size matching upload-box */
        .reference-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .video-char-reference {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .reference-grid {
            border: 1px solid #222;
            width: 100%;
            aspect-ratio: 16 / 9;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 4px;
            padding: 4px;
            align-content: start;
            overflow: hidden;
            flex: 0 0 auto;
        }

        .reference-item {
            position: relative;
            aspect-ratio: 1;
            border: 1px solid #444;
            overflow: hidden;
            cursor: pointer;
            min-width: 0;
        }

        .reference-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .reference-item .remove-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #999;
            width: 16px;
            height: 16px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .reference-item:hover .remove-btn {
            opacity: 1;
        }

        .reference-item .remove-btn:hover {
            color: #fff;
            border-color: #666;
        }

        .add-reference-box {
            border: 1px dashed #444;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 0;
        }

        .add-reference-box:hover:not(.disabled),
        .add-reference-box.dragover:not(.disabled) {
            border-color: #666;
            background: #1a1a1a;
        }

        .add-reference-box.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .video-char-reference.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .add-reference-box .plus-icon {
            font-size: 18px;
            color: #444;
        }

        .add-reference-box .label {
            font-size: 8px;
            letter-spacing: 0.05em;
            color: #444;
        }

        .reference-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 14px;
        }

        .reference-title {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
        }

        .edit-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .edit-title {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
        }

        .clear-all-refs {
            background: none;
            border: none;
            color: #444;
            font-size: 9px;
            cursor: pointer;
            padding: 0 8px;
            height: 14px;
            line-height: 14px;
        }

        .clear-all-refs:hover {
            color: #a44;
        }

        /* Reference Attribute Selectors */
        .ref-attributes {
            display: none;
        }

        .ref-attr-label {
            font-size: 9px;
            letter-spacing: 0.1em;
            color: #555;
            margin-bottom: 6px;
        }

        .ref-attr-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .ref-attr-btn {
            background: transparent;
            border: 1px solid #333;
            color: #555;
            font-size: 9px;
            letter-spacing: 0.05em;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ref-attr-btn:hover {
            border-color: #555;
            color: #888;
        }

        .ref-attr-btn.active {
            background: #1a1a1a;
            border-color: #4a9eff;
            color: #4a9eff;
        }

        .optional-badge {
            position: absolute;
            top: 6px;
            left: 6px;
            font-size: 8px;
            color: #444;
            letter-spacing: 0.05em;
        }

        /* Traits */
        .traits {
            font-size: 11px;
            color: #555;
            padding: 12px;
            background: #0d0d0d;
            border: 1px solid #1a1a1a;
            display: none;
        }

        .traits.visible {
            display: block;
        }

        .traits-label {
            color: #444;
            margin-bottom: 4px;
            font-size: 10px;
            letter-spacing: 0.1em;
        }

        .section-vertical-gap {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Prompt */
        .prompt-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .enhance-prompt-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 4px 8px;
            font-size: 9px;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 95px;
        }

        .enhance-prompt-btn:hover {
            border-color: #4a9eff;
            color: #4a9eff;
        }

        .enhance-prompt-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .enhance-prompt-btn.loading {
            display: flex !important;
            position: static !important;
            transform: none !important;
            pointer-events: none;
            opacity: 0.7;
        }

        .prompt-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .revert-prompt-btn {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 4px 8px;
            font-size: 9px;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }

        .revert-prompt-btn:hover {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .revert-prompt-btn.visible {
            display: flex;
        }

        .prompt-label {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
            display: block;
            height: 14px;
            line-height: 14px;
        }

        textarea {
            background: #111;
            border: 1px solid #222;
            color: #e5e5e5;
            padding: 12px;
            font-family: inherit;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            height: 90px;
            transition: border-color 0.2s;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        textarea::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        textarea:focus {
            outline: none;
            border-color: #444;
        }

        textarea::placeholder {
            color: #444;
        }

        /* Generate Button */
        .generate-btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 16px;
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: auto;
        }

        .generate-btn:hover:not(:disabled) {
            background: #e5e5e5;
        }

        .generate-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Error */
        .error {
            background: #1a0a0a;
            border: 1px solid #331a1a;
            color: #cc6666;
            padding: 10px 12px;
            font-size: 11px;
            display: none;
        }

        .error.visible {
            display: block;
        }

        /* Center Panel - Output */
        .output {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0d0d0d;
            min-width: 300px;
        }

        .output-header {
            padding: 16px 24px;
            border-bottom: 1px solid #1a1a1a;
            font-size: 13px;
            letter-spacing: 0.1em;
            color: #444;
        }

        .output-canvas {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .output-canvas img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Control bar zone - top only */
        .output-top-bar {
            height: 60px;
            min-height: 60px;
            background: #0d0d0d;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 14px;
            gap: 10px;
            position: relative;
            z-index: 20;
        }

        .output-top-bar .zoom-controls {
            margin-right: auto;
            /* Push zoom controls to the left */
        }

        .output-bottom-bar {
            height: 60px;
            min-height: 60px;
            background: #0d0d0d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            position: relative;
            z-index: 20;
        }

        .output-image-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            padding: 16px;
        }

        .output-placeholder {
            color: #333;
            font-size: 14px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Loading */
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
        }

        .loading.visible {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .spinner {
            width: 28px;
            height: 28px;
            border: 2px solid #222;
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 13px;
            color: #555;
            letter-spacing: 0.1em;
        }

        /* Download button */
        .download-btn {
            background: #000;
            border: 1px solid #333;
            color: #999;
            padding: 10px 16px;
            font-size: 11px;
            letter-spacing: 0.1em;
            cursor: pointer;
            display: none;
        }

        .download-btn.visible {
            display: block;
        }

        .download-btn:hover {
            background: #111;
            color: #fff;
        }

        /* Close output button */
        .close-output {
            background: #000;
            border: 1px solid #333;
            color: #666;
            width: 32px;
            height: 32px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .close-output.visible {
            display: flex;
        }

        .close-output:hover {
            color: #fff;
            border-color: #555;
        }

        /* Zoom controls */
        .zoom-controls {
            display: none;
            gap: 8px;
            align-items: center;
        }

        .zoom-controls.visible {
            display: flex;
        }

        .zoom-btn {
            background: #000;
            border: 1px solid #333;
            color: #999;
            width: 36px;
            height: 36px;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover:not(:disabled) {
            background: #111;
            color: #fff;
        }

        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .zoom-btn.compare-btn svg {
            width: 18px;
            height: 18px;
        }

        .zoom-btn.compare-btn:active:not(:disabled) {
            background: #333;
            color: #fff;
        }

        .zoom-level {
            font-size: 12px;
            color: #666;
            min-width: 50px;
            text-align: center;
        }

        /* Undo/Redo buttons - Desktop (top bar, centered) */
        .undo-redo-controls {
            display: none;
            gap: 8px;
            align-items: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .undo-redo-controls.visible {
            display: flex;
        }

        .undo-redo-btn {
            width: 36px;
            height: 36px;
            background: #000;
            border: 1px solid #333;
            border-radius: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .undo-redo-btn:hover:not(:disabled) {
            background: #111;
            color: #fff;
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .undo-redo-btn svg {
            width: 20px;
            height: 20px;
        }

        .undo-redo-btn svg path {
            stroke: #fff;
        }

                /* Mobile: undo/redo at bottom - ONLY visible on mobile */
        .mobile-undo-redo {
            display: none !important;
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            gap: 12px;
            z-index: 200;
            background: transparent;
            padding: 8px 16px;
        }

        .mobile-undo-redo.visible {
            display: flex;
        }

        /* Brush size preview circle */
        .brush-preview {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            background: rgba(255, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }

        .brush-preview.visible {
            opacity: 1;
        }

        /* Brush cursor that follows mouse */
        .brush-cursor {
            position: fixed;
            border: 2px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            background: rgba(255, 0, 0, 0.1);
            display: none;
            transform: translate(-50%, -50%);
        }

        .brush-cursor.visible {
            display: block;
        }

        /* Zoomable image container */
        .image-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-container.dragging {
            cursor: grabbing;
        }

        .image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transform-origin: center center;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .image-container:not(.dragging) img {
            transition: transform 0.15s ease-out;
        }

        /* Input header */
        .input-header {
            padding: 16px 24px;
            border-bottom: 1px solid #1a1a1a;
            font-size: 13px;
            color: #444;
            flex-shrink: 0;
        }

        /* Prompt/Edit Mode Toggle */
        .input-mode-toggle {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .input-mode-btn {
            flex: 1;
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 10px 16px;
            font-size: 11px;
            font-family: inherit;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .input-mode-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .input-mode-btn:hover:not(.active) {
            border-color: #555;
            color: #999;
        }

        .input-mode-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Video Mode Specific Styles */
        .video-model-section {
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .video-model-section.visible {
            display: flex;
        }

        .video-frames-container {
            display: none;
            flex-direction: column;
            gap: 12px;
        }

        .video-frames-container.visible {
            display: flex;
        }

        .video-frame-box {
            border: 1px dashed #333;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #0a0a0a;
            position: relative;
            aspect-ratio: 16 / 9;
            overflow: hidden;
        }

        .video-frame-box .frame-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .video-frame-box:hover:not(.disabled),
        .video-frame-box.dragover:not(.disabled) {
            border-color: #555;
            background: #111;
        }

        .video-frame-box.has-image {
            border-style: solid;
        }

        .video-frame-box.has-image .frame-content {
            display: none;
        }

        .video-frame-wrapper.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .video-frame-box.disabled {
            opacity: 1;
            cursor: not-allowed;
        }

        .frame-header {
            display: flex;
            justify-content: flex-start;
        }

        .frame-label-external {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
        }

        .settings-title {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            display: block;
            text-transform: uppercase;
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }

        .video-frame-box .frame-label {
            display: none;
        }

        .video-frame-box .frame-hint {
            font-size: 12px;
            color: #444;
        }

        .video-frame-box .frame-preview,
        .video-frame-box .video-frame-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        .video-frame-box .clear-frame-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            color: #999;
            font-size: 18px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 0;
            display: none;
            line-height: 1;
            z-index: 10;
        }

        .video-frame-box.has-image .clear-frame-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-frame-box .clear-frame-btn:hover {
            color: #fff;
            border-color: #666;
        }

        .video-frame-box.has-image .frame-label,
        .video-frame-box.has-image .frame-hint {
            display: none;
        }

        /* Audio Toggle (Video Mode - Kling 2.6 only) */
        .audio-toggle-section {
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .audio-toggle-section.visible {
            display: flex;
        }

        .audio-toggle-label {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
        }

        .audio-toggle {
            display: flex;
            width: 100%;
        }

        .audio-toggle-btn {
            flex: 1;
            background: transparent;
            border: 1px solid #333;
            color: #666;
            height: 32px;
            font-size: 12px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-toggle-btn:first-child {
            border-right: none;
        }

        .audio-toggle-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

.audio-toggle-btn:hover:not(.active) {
    border-color: #555;
    color: #999;
}

.video-prompt-output {
    display: none;
    flex-direction: column;
    gap: 16px;
    background: #0a0a0a;
    border: 1px solid #222;
    padding: 16px;
    margin: 20px;
    flex: 1;
    max-width: 800px;
    align-self: center;
    width: calc(100% - 40px);
}

.video-prompt-output.visible {
    display: flex;
}

        .video-prompt-output .prompt-output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .video-prompt-output .prompt-output-label {
            font-size: 12px;
            letter-spacing: 0.1em;
            color: #888;
            font-weight: 500;
        }

        .video-prompt-output .copy-prompt-btn {
            background: transparent;
            border: 1px solid #333;
            color: #888;
            padding: 0 12px;
            height: 32px;
            font-size: 11px;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-prompt-output .copy-prompt-btn:hover {
            border-color: #555;
            color: #fff;
        }

        .video-prompt-output .prompt-output-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .video-prompt-output .close-prompt-output {
            background: transparent;
            border: 1px solid #333;
            color: #888;
            width: 32px;
            height: 32px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-prompt-output .close-prompt-output:hover {
            border-color: #555;
            color: #fff;
        }

        .video-prompt-output textarea.prompt-output-text {
            background: #111;
            border: 1px solid #222;
            padding: 16px;
            color: #e5e5e5;
            font-size: 13px;
            line-height: 1.7;
            min-height: 300px;
            flex: 1;
            overflow-y: auto;
            resize: vertical;
            font-family: inherit;
            white-space: pre-wrap;
            width: 100%;
            box-sizing: border-box;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .video-prompt-output textarea.prompt-output-text::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .video-prompt-output textarea.prompt-output-text:focus {
            outline: none;
            border-color: #444;
        }

        .video-prompt-output .generate-video-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .video-prompt-output .generate-video-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .video-prompt-output .generate-video-btn:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Video Container */
        .video-container {
            display: none;
            width: 100%;
            max-width: 100%;
            position: relative;
        }

        .video-container.visible {
            display: block;
        }

        .video-container video {
            width: 100%;
            max-height: 70vh;
            background: #000;
            border-radius: 4px;
        }

        /* Model selector */
        .model-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 14px;
        }

        .model-label {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
            display: block;
            height: 14px;
            line-height: 14px;
        }

        .reset-all-btn {
            background: none;
            border: none;
            color: #444;
            font-size: 9px;
            cursor: pointer;
            padding: 0 8px;
            height: 14px;
            line-height: 14px;
            display: none;
        }

        .reset-all-btn:hover {
            color: #a44;
        }

        .model-select {
            background: #111;
            border: 1px solid #222;
            color: #e5e5e5;
            padding: 10px 12px;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .model-select:focus {
            outline: none;
            border-color: #444;
        }

        .model-select option {
            background: #111;
            color: #e5e5e5;
        }

        .model-select option:disabled {
            color: #444;
        }

        /* Canvas Tools Sidebar */
        .canvas-tools {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 30;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            padding: 12px 8px;
        }

        .canvas-tools.visible {
            display: flex;
        }

        /* Vertical Brush Size Slider */
        .brush-slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .brush-size-label {
            font-size: 9px;
            color: #666;
            letter-spacing: 0.05em;
        }

        .brush-slider {
            writing-mode: vertical-lr;
            direction: rtl;
            width: 24px;
            height: 120px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .brush-slider::-webkit-slider-runnable-track {
            width: 4px;
            height: 100%;
            background: #333;
            border-radius: 2px;
        }

        .brush-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-left: -6px;
        }

        .brush-slider::-moz-range-track {
            width: 4px;
            height: 100%;
            background: #333;
            border-radius: 2px;
        }

        .brush-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .brush-size-value {
            font-size: 10px;
            color: #888;
            min-width: 28px;
            text-align: center;
        }

        /* Tool Buttons */
        .canvas-tool-btns {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .canvas-tool-btn {
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid #333;
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .canvas-tool-btn:hover {
            border-color: #555;
            color: #999;
        }

        .canvas-tool-btn.active {
            background: #fff;
            border-color: #fff;
        }

        .canvas-tool-btn.active svg path {
            fill: #000;
            stroke: #000;
        }

        .canvas-tool-btn svg {
            width: 20px;
            height: 20px;
        }

        .canvas-tool-btn svg path {
            fill: currentColor;
            stroke: currentColor;
        }

        /* Edit Canvas Overlay */
        .edit-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .edit-canvas-container.visible {
            display: flex;
        }

        .edit-canvas-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .edit-base-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            user-select: none;
            -webkit-user-drag: none;
        }

        .edit-mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            opacity: 0.6;
            cursor: none;
        }

        .edit-mask-canvas.drawing {
            cursor: none;
        }

        .edit-mask-canvas.moving {
            cursor: grab;
        }

        .edit-mask-canvas.moving.dragging {
            cursor: grabbing;
        }

        /* Edit mode placeholder */
        .edit-mode-placeholder {
            color: #444;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        .edit-mode-placeholder.visible {
            display: block;
        }

        /* Model-Specific Parameters */
        .model-params-section {
            margin-bottom: 0;
        }

        .model-params {
            background: #0a0a0a;
            border: 1px solid #222;
            padding: 12px;
        }

        .param-row {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
        }

        .param-row:last-child {
            margin-bottom: 0;
        }

        .param-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .param-label {
            font-size: 10px;
            letter-spacing: 0.1em;
            color: #666;
        }

        .param-select {
            background: #111;
            border: 1px solid #333;
            color: #e5e5e5;
            padding: 0 10px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            height: 32px;
            box-sizing: border-box;
            width: 100%;
        }

        .param-select:focus {
            outline: none;
            border-color: #555;
        }

        .param-input {
            background: #111;
            border: 1px solid #333;
            color: #e5e5e5;
            padding: 0 10px;
            font-family: inherit;
            font-size: 12px;
            height: 32px;
            box-sizing: border-box;
            width: 100%;
        }

        .param-input:focus {
            outline: none;
            border-color: #555;
        }

        .param-input::placeholder {
            color: #555;
        }

        .param-toggle .toggle-buttons {
            display: flex;
            gap: 0;
        }

        .param-toggle .toggle-btn {
            flex: 1;
            padding: 8px 12px;
            background: #111;
            border: 1px solid #333;
            color: #666;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .param-toggle .toggle-btn:first-child {
            border-right: none;
        }

        .param-toggle .toggle-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .param-toggle .toggle-btn:hover:not(.active) {
            border-color: #555;
            color: #999;
        }

        /* Nano Pro specific adjustments */
        #nano-pro-seed {
            width: 100%;
        }

        .param-slider {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .param-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .param-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        .seed-input-wrapper {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .seed-input-wrapper .seed-input {
            flex: 1;
        }

        .seed-input.has-value {
            background: #1a2a1a;
            border-color: #2a4a2a;
        }

        .seed-hint {
            display: block;
        }

        .history-item-seed {
            display: inline;
            font-size: 9px;
            color: #4a9;
            margin-left: 6px;
            font-family: monospace;
        }

        /* Audio Upload Box (Avatar Mode) */
        .avatar-audio-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .audio-upload-box {
            border: 1px dashed #333;
            text-align: center;
            cursor: pointer;
            background: #0a0a0a;
            border-radius: 0;
            position: relative;
            height: 60px;
            overflow: hidden;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-upload-box:hover:not(.disabled) {
            border-color: #555;
            background: #111;
        }

        .audio-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
        }

        .audio-placeholder .upload-text {
            font-size: 12px;
            color: #444;
        }

        .audio-preview {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .audio-preview audio {
            flex: 1;
            height: 32px;
        }

        .remove-audio-btn {
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            color: #999;
            width: 24px;
            height: 24px;
            border-radius: 0;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .remove-audio-btn:hover {
            color: #fff;
            border-color: #666;
        }

        /* Resolution dropdown */
        .resolution-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .resolution-label {
            font-size: 11px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
            margin: 0;
            padding: 0;
            height: 14px;
            line-height: 14px;
        }

        .resolution-select {
            background: #111;
            border: 1px solid #222;
            color: #e5e5e5;
            padding: 10px 12px;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .resolution-select:focus {
            outline: none;
            border-color: #444;
        }

        .resolution-select option {
            background: #111;
            color: #e5e5e5;
        }

        /* Right Panel - History */
        .history-panel {
            width: 350px;
            min-width: 250px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            background: #080808;
            flex-shrink: 0;
        }

        .history-header {
            padding: 16px;
            border-bottom: 1px solid #1a1a1a;
            font-size: 13px;
            letter-spacing: 0.1em;
            color: #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clear-historyItems {
            background: none;
            border: none;
            color: #444;
            font-size: 9px;
            cursor: pointer;
        }

        .clear-historyItems:hover {
            color: #a44;
        }

        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .history-list::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .history-item {
            cursor: pointer;
            border: 1px solid transparent;
            transition: border-color 0.2s;
            flex-shrink: 0;
            position: relative;
        }

        .history-item:hover {
            border-color: #333;
        }

        /* NEW badge */
        .new-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: #fff;
            color: #000;
            font-size: 9px;
            font-weight: 600;
            padding: 2px 6px;
            letter-spacing: 0.05em;
            z-index: 10;
        }

        .history-item img {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            display: block;
        }

        /* Video prompt historyItems item - text preview instead of image */
        .history-item.video-prompt-item .video-prompt-preview {
            width: 100%;
            aspect-ratio: 16/9;
            background: #0a0a0a;
            border-bottom: 1px solid #222;
            padding: 12px;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .history-item.video-prompt-item .video-prompt-preview .video-label {
            font-size: 9px;
            letter-spacing: 0.1em;
            color: #666;
            text-transform: uppercase;
        }

        .history-item.video-prompt-item .video-prompt-preview .video-text {
            font-size: 11px;
            color: #999;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
        }

        /* Generated video history item */
        .history-item.video-item .video-preview {
            width: 100%;
            aspect-ratio: 16/9;
            background: #0a0a0a;
            border-bottom: 1px solid #222;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .history-item.video-item .video-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .history-item.video-item .video-preview .video-placeholder {
            font-size: 12px;
            letter-spacing: 0.1em;
            color: #444;
        }

        .history-item.video-item .video-preview .video-play-icon {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            z-index: 2;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s;
        }

        .history-item.video-item .video-preview:hover .video-play-icon {
            transform: scale(1.2);
        }

        .history-item-info {
            padding: 6px 8px;
            background: #111;
        }

        .history-item-prompt {
            font-size: 13px;
            color: #e5e5e5;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
            transition: color 0.2s;
        }

        .history-item-time {
            font-size: 11px;
            color: #444;
        }

        .history-item-info {
            padding: 12px 16px;
            background: #111;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .history-item-text {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        .history-item-actions {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
        }

        .history-action-btn {
            background: transparent;
            border: none;
            color: #444;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .history-action-btn:hover {
            color: #fff;
            transform: scale(1.1);
        }

        .history-action-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Tabs */
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid #1a1a1a;
        }

        .panel-tab {
            flex: 1;
            padding: 16px;
            font-size: 13px;
            letter-spacing: 0.1em;
            color: #444;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .panel-tab:hover {
            color: #666;
        }

        .panel-tab.active {
            color: #e5e5e5;
            background: #0d0d0d;
        }

        .clear-btn-header {
            flex: 1;
            background: none;
            border: none;
            color: #444;
            font-size: 13px;
            letter-spacing: 0.1em;
            cursor: pointer;
            padding: 16px;
            transition: all 0.2s;
            text-align: center;
        }

        .clear-btn-header:hover {
            color: #a44;
        }

        .history-empty {
            color: #333;
            font-size: 13px;
            text-align: center;
            padding: 32px;
        }

        /* Lightbox */
        .lightbox-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            backdrop-filter: blur(8px);
        }

        .lightbox-overlay.visible {
            display: flex;
        }

        .lightbox-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
        }

        .lightbox-content img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border: 1px solid #333;
        }

        .lightbox-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: none;
            border: none;
            color: #888;
            font-size: 32px;
            cursor: pointer;
            padding: 8px;
            line-height: 1;
        }

        .lightbox-close:hover {
            color: #fff;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            padding: 32px;
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .modal-title {
            font-size: 13px;
            letter-spacing: 0.1em;
            color: #fff;
            text-align: center;
        }

        .modal-text {
            font-size: 14px;
            color: #666;
            text-align: center;
            line-height: 1.5;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
        }

        .modal-btn {
            flex: 1;
            padding: 14px;
            font-family: inherit;
            font-size: 11px;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #333;
        }

        .modal-btn-cancel {
            background: transparent;
            color: #666;
        }

        .modal-btn-confirm {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .modal-btn-cancel:hover {
            color: #fff;
            border-color: #444;
        }

        .modal-btn-confirm:hover {
            background: #e5e5e5;
        }

        /* Responsive - Desktop/Tablet */
        @media (max-width: 1000px) {
            .history-panel {
                display: none;
            }
        }

        /* Mobile Tab Bar - hidden on desktop */
        .mobile-tabs {
            display: none;
        }

        /* ===========================================
           MOBILE PORTRAIT LAYOUT
           =========================================== */

        /* Landscape orientation block - show rotate message */
        @media (max-width: 900px) and (orientation: landscape) {
            body {
                overflow: hidden;
            }

            body::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #0a0a0a;
                z-index: 9999;
            }

            body::after {
                content: 'Please rotate your device to portrait mode';
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #666;
                font-size: 16px;
                text-align: center;
                letter-spacing: 0.1em;
                z-index: 10000;
                padding: 20px;
            }

            header,
            main,
            .mobile-tabs,
            .modal-overlay,
            .lightbox-overlay {
                display: none !important;
            }
        }

        /* Mobile Portrait Layout */
        @media (max-width: 768px) and (orientation: portrait) {
            body {
                height: 100vh;
                height: 100dvh;
                /* Dynamic viewport height for mobile browsers */
                overflow: hidden;
            }

            /* Compact Header */
            header {
                padding: 12px 16px;
                flex-shrink: 0;
            }

            .logo span {
                font-size: 13px;
                letter-spacing: 0.25em;
            }

            .mode-btn {
                padding: 6px 12px;
                font-size: 10px;
            }

            .status {
                display: none;
                /* Hide status on mobile for space */
            }

            /* Main area fills remaining space */
            main {
                flex: 1;
                position: relative;
                height: calc(100dvh - 49px - 56px);
                /* header - tab bar */
                overflow: hidden;
            }

            /* Hide resizers on mobile */
            .resizer {
                display: none !important;
            }

            /* Mobile Tab Bar */
            .mobile-tabs {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 56px;
                background: #0a0a0a;
                border-top: 1px solid #1a1a1a;
                z-index: 100;
            }

            .mobile-tab {
                flex: 1;
                background: transparent;
                border: none;
                color: #555;
                font-family: inherit;
                font-size: 11px;
                letter-spacing: 0.1em;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mobile-tab.active {
                color: #fff;
                background: #111;
            }

            .mobile-tab:not(.active):active {
                background: #0d0d0d;
            }

            /* Panel Styles - Show only active panel */
            .inputs,
            .output,
            .history-panel {
                position: absolute;
                top: 0;
                left: 0;
                width: 100% !important;
                height: 100% !important;
                max-width: none !important;
                min-width: 0 !important;
                display: none;
                flex-direction: column;
            }

            .inputs.mobile-active,
            .output.mobile-active,
            .history-panel.mobile-active {
                display: flex;
            }

            /* Input Panel Mobile */
            .inputs {
                padding: 16px;
                gap: 12px;
                overflow-y: auto;
                padding-bottom: 80px;
                /* Space for tab bar */
            }

            .input-header {
                display: none;
                /* Hide on mobile, we have tabs */
            }

            .upload-box {
                aspect-ratio: 4 / 3;
                min-height: 120px;
            }

            /* Reference grid mobile styles */
            .reference-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }

            .upload-box .label {
                font-size: 10px;
            }

            .upload-box .hint {
                font-size: 11px;
            }

            .upload-box .clear-btn {
                width: 32px;
                height: 32px;
                font-size: 18px;
                top: 8px;
                right: 8px;
            }

            textarea {
                height: 80px;
                font-size: 14px;
                /* Prevent iOS zoom */
            }

            .resolution-section {
                flex-direction: column;
                gap: 10px;
            }

            .resolution-select {
                font-size: 14px;
                /* Prevent iOS zoom */
                padding: 12px;
            }

            .generate-btn {
                position: fixed;
                bottom: 56px;
                /* Above the mobile tab bar */
                left: 0;
                right: 0;
                padding: 16px;
                font-size: 14px;
                margin: 0;
                z-index: 50;
                border-radius: 0;
            }

            /* Add extra padding at bottom of inputs to account for fixed button */
            .inputs {
                padding-bottom: 140px !important;
                /* Space for fixed generate button + tab bar */
            }

            /* Output Panel Mobile */
            .output {
                background: #0a0a0a;
            }

            .output-header {
                display: none;
                /* Hide on mobile, we have tabs */
            }

            .output-canvas {
                flex: 1;
            }

            .output-top-bar {
                height: auto;
                min-height: 50px;
                padding: 10px;
                gap: 6px;
                flex-wrap: nowrap;
                /* Keep all controls in one row */
            }

            .output-top-bar .zoom-controls {
                gap: 4px;
            }

            .output-top-bar .zoom-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }

            .output-top-bar .zoom-level {
                font-size: 11px;
                min-width: 42px;
            }

            .output-top-bar .download-btn {
                padding: 0 12px;
                font-size: 10px;
                height: 36px;
                align-items: center;
                /* Keep display: none by default, only show when .visible */
            }

            .output-top-bar .download-btn.visible {
                display: flex;
            }

            .close-output {
                width: 36px;
                height: 36px;
                font-size: 20px;
                flex-shrink: 0;
            }

                        /* Hide desktop undo/redo on mobile - use mobile-undo-redo instead */
            .undo-redo-controls {
                display: none !important;
            }

            /* Show mobile undo/redo on mobile when visible */
            .mobile-undo-redo.visible {
                display: flex !important;
            }

            .zoom-controls {
                gap: 6px;
            }

            .zoom-btn {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }

            .zoom-level {
                font-size: 12px;
                min-width: 50px;
            }

            .download-btn {
                padding: 12px 16px;
                font-size: 12px;
            }

            .output-placeholder {
                font-size: 13px;
                padding: 20px;
            }

            /* History Panel Mobile */
            .history-panel {
                padding-bottom: 56px;
                /* Space for tab bar */
            }

            .history-header {
                flex-direction: column;
                gap: 0;
                padding: 0;
            }

            .history-tabs {
                width: 100%;
                border-bottom: 1px solid #1a1a1a;
            }

            .history-tab {
                padding: 14px 16px;
                font-size: 11px;
            }

            .clear-btn-header {
                padding: 14px 16px;
                font-size: 11px;
            }

            .history-list {
                padding: 12px;
                gap: 10px;
            }

            .history-item img {
                aspect-ratio: 16 / 9;
            }

            .history-item-info {
                padding: 10px 12px;
            }

            .history-item-prompt {
                font-size: 12px;
            }

            .history-item-time {
                font-size: 10px;
            }

            .history-item-actions {
                gap: 4px;
            }

            .history-action-btn {
                width: 40px;
                height: 40px;
                padding: 8px;
            }

            .history-action-btn svg {
                width: 24px;
                height: 24px;
            }

            /* Traits display mobile */
            .traits {
                padding: 10px;
                font-size: 10px;
            }

            .traits-label {
                font-size: 9px;
            }

            /* Lightbox mobile */
            .lightbox-content {
                max-width: 95vw;
                max-height: 85vh;
            }

            .lightbox-content img {
                max-width: 95vw;
                max-height: 85vh;
            }

            .lightbox-close {
                top: -45px;
                font-size: 36px;
            }

            /* Modal mobile */
            .modal {
                margin: 16px;
                max-width: calc(100% - 32px);
            }

            .modal-title {
                font-size: 12px;
            }

            .modal-text {
                font-size: 12px;
            }

            .modal-btn {
                padding: 14px 20px;
                font-size: 11px;
            }
        }

        /* Small mobile devices */
        @media (max-width: 380px) and (orientation: portrait) {
            .logo {
                font-size: 12px;
                letter-spacing: 0.2em;
            }

            .mode-btn {
                padding: 5px 10px;
                font-size: 9px;
            }

            .mobile-tab {
                font-size: 9px;
            }

            .upload-box .label {
                font-size: 9px;
            }

            .history-item-actions {
                gap: 2px;
            }

            .history-action-btn {
                width: 36px;
                height: 36px;
                padding: 6px;
            }

            .history-action-btn svg {
                width: 22px;
                height: 22px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">
            <span>VIEWR</span>
        </div>
        <div class="header-right">
            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="draft">DRAFT</button>
                <button class="mode-btn" data-mode="pro">PRO</button>
            </div>
            <span class="storage-indicator" id="storage-indicator" title="MongoDB Storage Usage">
                <span class="storage-bar">
                    <span class="storage-fill" id="storage-fill"></span>
                </span>
                <span class="storage-text" id="storage-text">--</span>
            </span>
        </div>
    </header>

    <main>
        <div class="inputs" id="left-panel">
            <div class="input-header">INPUT</div>
            <div class="inputs-content">

            <!-- Prompt/Edit/Video Mode Toggle -->
            <div class="input-mode-toggle">
                <button class="input-mode-btn active" data-input-mode="prompt">PROMPT</button>
                <button class="input-mode-btn" data-input-mode="edit">EDIT</button>
                <button class="input-mode-btn" data-input-mode="video">VIDEO</button>
            </div>

            <!-- Model Selector (Image modes) -->
            <div class="model-section" id="model-section">
                <div class="model-header">
                    <label class="model-label">MODEL</label>
                    <button class="reset-all-btn" id="reset-all-image">RESET ALL</button>
                </div>
                <select class="model-select" id="model-select">
                    <option value="nano-banana">Nano Banana</option>
                    <option value="gpt-image-1.5-low">GPT Image 1.5 (Low)</option>
                </select>
            </div>

            <!-- Video Model Selector (Video mode only) -->
            <div class="video-model-section" id="video-model-section">
                <div class="model-header">
                    <label class="model-label">VIDEO MODEL</label>
                    <button class="reset-all-btn" id="reset-all-video">RESET ALL</button>
                </div>
                <select class="model-select" id="video-model-select">
                    <optgroup label="Kling 2.6 Pro">
                        <option value="kling-2.6-i2v">Kling 2.6 Pro  Image-to-Video</option>
                        <option value="kling-2.6-t2v">Kling 2.6 Pro  Text-to-Video</option>
                        <option value="kling-2.6-motion">Kling 2.6 Pro  Motion Control</option>
                    </optgroup>
                    <optgroup label="Kling O1">
                        <option value="kling-o1-pro-i2v">Kling O1 Pro  Image-to-Video</option>
                        <option value="kling-o1-pro-v2v">Kling O1 Pro  Video-to-Video</option>
                        <option value="kling-o1-std-i2v">Kling O1 Standard  Image-to-Video</option>
                        <option value="kling-o1-std-v2v">Kling O1 Standard  Video-to-Video</option>
                    </optgroup>
                    <optgroup label="Kling 2.5 Turbo">
                        <option value="kling-2.5-pro-i2v">Kling 2.5 Turbo Pro  Image-to-Video</option>
                        <option value="kling-2.5-pro-t2v">Kling 2.5 Turbo Pro  Text-to-Video</option>
                        <option value="kling-2.5-std-i2v">Kling 2.5 Turbo Standard  Image-to-Video</option>
                    </optgroup>
                    <optgroup label="Kling 2.1">
                        <option value="kling-2.1-master-i2v">Kling 2.1 Master  Image-to-Video</option>
                        <option value="kling-2.1-master-t2v">Kling 2.1 Master  Text-to-Video</option>
                        <option value="kling-2.1-pro-i2v">Kling 2.1 Pro  Image-to-Video</option>
                    </optgroup>
                    <optgroup label="Kling Avatar">
                        <option value="kling-avatar">Kling AI Avatar v2 Pro  Lip-Sync</option>
                    </optgroup>
                </select>
            </div>

            <!-- Video Frames (Video mode only) -->
            <div class="video-frames-container" id="video-frames-container">
                <!-- Character Reference (Video mode) -->
                <div class="video-char-reference section-vertical-gap" id="video-char-reference">
                    <div class="reference-header">
                        <span class="reference-title">CHARACTER REFERENCES</span>
                        <button class="clear-all-refs" id="clear-video-char-ref" style="display: none;">CLEAR</button>
                    </div>
                    <div class="reference-grid video-char-grid" id="video-char-grid">
                        <div class="add-reference-box" id="add-video-char-box">
                            <span class="plus-icon">+</span>
                            <span class="label">ADD</span>
                        </div>
                    </div>
                    <input type="file" id="video-char-input" accept="image/*" multiple style="display: none;">
                    
                    <!-- Character Reference Attributes -->
                    <div class="ref-attributes video-char-attributes" id="video-char-attributes" style="display: none;">
                        <div class="ref-attr-label">CHARACTER ATTRIBUTES</div>
                        <div class="ref-attr-grid">
                            <button type="button" class="ref-attr-btn active" data-attr="face">FACE</button>
                            <button type="button" class="ref-attr-btn active" data-attr="hair">HAIR</button>
                            <button type="button" class="ref-attr-btn" data-attr="facial-jewelry">FACIAL JEWELRY</button>
                            <button type="button" class="ref-attr-btn" data-attr="headwear">HEADWEAR</button>
                            <button type="button" class="ref-attr-btn" data-attr="clothing">CLOTHING</button>
                            <button type="button" class="ref-attr-btn" data-attr="accessories">ACCESSORIES</button>
                            <button type="button" class="ref-attr-btn" data-attr="pose">POSE</button>
                            <button type="button" class="ref-attr-btn" data-attr="body">BODY</button>
                        </div>
                    </div>
                    
                    <!-- Detected Character Traits -->
                    <div class="traits video-char-traits" id="video-char-traits-display" style="display: none;">
                        <div class="traits-label">DETECTED CHARACTER TRAITS</div>
                        <div id="video-char-traits-text"></div>
                    </div>
                </div>
                
                <div class="video-frame-wrapper section-vertical-gap" id="start-frame-wrapper">
                    <div class="frame-header">
                        <span class="frame-label-external" id="start-frame-label">START FRAME</span>
                    </div>
                    <div class="video-frame-box" id="start-frame-box">
                        <div class="frame-content">
                            <span class="frame-label">START FRAME</span>
                            <span class="frame-hint">Opening shot</span>
                        </div>
                        <button class="clear-frame-btn" onclick="event.stopPropagation(); clearVideoFrame('start')">&times;</button>
                        <input type="file" id="start-frame-input" accept="image/*" style="display: none;">
                    </div>
                </div>
                <div class="video-frame-wrapper section-vertical-gap" id="end-frame-wrapper">
                    <div class="frame-header">
                        <span class="frame-label-external" id="end-frame-label">END FRAME</span>
                    </div>
                    <div class="video-frame-box" id="end-frame-box">
                        <span class="optional-badge">OPTIONAL</span>
                        <div class="frame-content">
                            <span class="frame-label">END FRAME</span>
                            <span class="frame-hint">Closing shot</span>
                        </div>
                        <button class="clear-frame-btn" onclick="event.stopPropagation(); clearVideoFrame('end')">&times;</button>
                        <input type="file" id="end-frame-input" accept="image/*" style="display: none;">
                    </div>
                </div>
            </div>

            <!-- Reference Images (Multiple) -->
            <div class="reference-container" id="reference-container">
                <div class="reference-header">
                    <span class="reference-title">CHARACTER REFERENCES</span>
                    <button class="clear-all-refs" id="clear-all-refs" style="display: none;">CLEAR ALL</button>
                </div>
                <div class="reference-grid" id="reference-grid">
                    <div class="add-reference-box" id="add-reference-box">
                        <span class="plus-icon">+</span>
                        <span class="label">ADD</span>
                    </div>
                </div>
                <input type="file" id="reference-input" accept="image/*" multiple style="display: none;">
                
                <!-- Reference Attribute Selectors -->
                <div class="ref-attributes" id="ref-attributes">
                    <div class="ref-attr-label">CHARACTER ATTRIBUTES</div>
                    <div class="ref-attr-grid">
                        <button class="ref-attr-btn active" data-attr="face">FACE</button>
                        <button class="ref-attr-btn active" data-attr="hair">HAIR</button>
                        <button class="ref-attr-btn" data-attr="facial-jewelry">FACIAL JEWELRY</button>
                        <button class="ref-attr-btn" data-attr="headwear">HEADWEAR</button>
                        <button class="ref-attr-btn" data-attr="clothing">CLOTHING</button>
                        <button class="ref-attr-btn" data-attr="accessories">ACCESSORIES</button>
                        <button class="ref-attr-btn" data-attr="pose">POSE</button>
                        <button class="ref-attr-btn" data-attr="body">BODY</button>
                    </div>
                </div>
            </div>

            <!-- Edit Image (Optional) -->
            <div class="edit-container" id="edit-container">
                <div class="edit-header">
                    <span class="edit-title">EDIT IMAGE</span>
                </div>
                <div class="upload-box" id="edit-box">
                    <span class="optional-badge">OPTIONAL</span>
                    <div class="upload-content">
                        <span class="hint">Image to modify</span>
                    </div>
                    <button class="clear-btn" onclick="event.stopPropagation(); clearImage('edit')">&times;</button>
                    <input type="file" id="edit-input" accept="image/*">
                </div>
            </div>

            <!-- Detected Traits (Reference) -->
            <div class="traits" id="traits-display">
                <div class="traits-label">DETECTED TRAITS</div>
                <div id="traits-text"></div>
            </div>

            <!-- Detected Traits (Edit Image) -->
            <div class="traits" id="edit-traits-display">
                <div class="traits-label">EDIT IMAGE DETAILS</div>
                <div id="edit-traits-text"></div>
            </div>

            <!-- Audio Toggle (Kling 2.6 only) -->
            <div class="audio-toggle-section" id="audio-toggle-section">
                <label class="audio-toggle-label">AUDIO</label>
                <div class="audio-toggle">
                    <button class="audio-toggle-btn" data-audio="off">OFF</button>
                    <button class="audio-toggle-btn active" data-audio="on">ON</button>
                </div>
            </div>

            <!-- Prompt -->
            <div class="prompt-section">
                <div class="prompt-header">
                    <label class="prompt-label">PROMPT</label>
                    <div class="prompt-actions">
                        <button class="revert-prompt-btn" id="revert-prompt-btn" title="Revert to original prompt">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                <path d="M3 3v5h5"/>
                            </svg>
                            REVERT
                        </button>
                        <button class="enhance-prompt-btn" id="enhance-prompt-btn" title="Enhance prompt using AI">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                            </svg>
                            ENHANCE
                        </button>
                    </div>
                </div>
                <textarea id="prompt" placeholder="Describe what you want..."></textarea>
            </div>

            <!-- Model-Specific Parameters Section -->
            <div class="model-params-section" id="model-params-section">
                <!-- GPT Image 1.5 Parameters -->
                <div id="gpt-image-params" class="resolution-section" style="display: none;">
                    <label class="resolution-label">SETTINGS</label>
                    <div class="model-params">
                        <div class="param-row">
                            <div class="param-group">
                                <label class="param-label">BACKGROUND</label>
                                <select class="param-select" id="gpt-background">
                                    <option value="auto">Auto</option>
                                    <option value="transparent">Transparent</option>
                                    <option value="opaque">Opaque</option>
                                </select>
                            </div>
                            <div class="param-group">
                                <label class="param-label">OUTPUT FORMAT</label>
                                <select class="param-select" id="gpt-output-format">
                                    <option value="png">PNG</option>
                                    <option value="jpeg">JPEG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                        </div>
                        <div class="param-row" id="gpt-fidelity-row" style="display: none;">
                            <div class="param-group">
                                <label class="param-label">INPUT FIDELITY</label>
                                <select class="param-select" id="gpt-input-fidelity">
                                    <option value="high">High</option>
                                    <option value="low">Low</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Nano Banana Parameters -->
                <div id="nano-banana-params" class="resolution-section" style="display: none;">
                    <label class="resolution-label">SETTINGS</label>
                    <div class="model-params">
                        <div class="param-row">
                            <div class="param-group">
                                <label class="param-label">OUTPUT FORMAT</label>
                                <select class="param-select" id="nano-output-format">
                                    <option value="png">PNG</option>
                                    <option value="jpeg">JPEG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Nano Banana Pro Parameters -->
                <div id="nano-pro-params" class="resolution-section" style="display: none;">
                    <label class="resolution-label">SETTINGS</label>
                    <div class="model-params">
                        <div class="param-row">
                            <div class="param-group">
                                <label class="param-label">OUTPUT FORMAT</label>
                                <select class="param-select" id="nano-pro-output-format">
                                    <option value="png">PNG</option>
                                    <option value="jpeg">JPEG</option>
                                    <option value="webp">WebP</option>
                                </select>
                            </div>
                            <div class="param-group">
                                <label class="param-label">SEED</label>
                                <div class="seed-input-wrapper">
                                    <input type="text" class="param-input seed-input" id="nano-pro-seed" placeholder="Random" pattern="[0-9]*">
                                </div>
                            </div>
                        </div>
                        <div class="param-row">
                            <div class="param-group param-toggle">
                                <label class="param-label">WEB SEARCH</label>
                                <div class="toggle-buttons">
                                    <button class="toggle-btn" data-value="false" id="web-search-off">OFF</button>
                                    <button class="toggle-btn active" data-value="true" id="web-search-on">ON</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Video Model Parameters (includes Motion Control) -->
                <div id="video-params" class="resolution-section" style="display: none;">
                    <label class="resolution-label">SETTINGS</label>
                    <div class="model-params">
                        <div class="param-row">
                            <div class="param-group">
                                <label class="param-label">DURATION</label>
                                <select class="param-select" id="video-duration">
                                    <option value="5">5 seconds</option>
                                    <option value="10">10 seconds</option>
                                </select>
                            </div>
                            <div class="param-group">
                                <label class="param-label">NEGATIVE PROMPT</label>
                                <input type="text" class="param-input" id="video-negative-prompt" placeholder="blur, distort, low quality" value="blur, distort, and low quality">
                            </div>
                        </div>
                        <div class="param-row" id="cfg-scale-row" style="display: none;">
                            <div class="param-group">
                                <label class="param-label">CFG SCALE <span id="cfg-scale-value">0.5</span></label>
                                <input type="range" class="param-slider" id="video-cfg-scale" min="0" max="1" step="0.1" value="0.5">
                            </div>
                        </div>
                        
                        <!-- Motion Control Rows (Merged into Video box) -->
                        <div id="motion-control-params" style="display: none;">
                            <div class="param-row">
                                <div class="param-group">
                                    <label class="param-label">CHARACTER ORIENTATION</label>
                                    <select class="param-select" id="motion-char-orientation">
                                        <option value="video">Match Video (max 30s)</option>
                                        <option value="image">Match Image (max 10s)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="param-row">
                                <div class="param-group param-toggle">
                                    <label class="param-label">KEEP ORIGINAL SOUND</label>
                                    <div class="toggle-buttons">
                                        <button class="toggle-btn" data-value="false" id="keep-sound-off">OFF</button>
                                        <button class="toggle-btn active" data-value="true" id="keep-sound-on">ON</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Avatar Audio Upload (Kling Avatar) -->
                <div class="avatar-audio-section" id="avatar-audio-section" style="display: none;">
                    <div class="prompt-header">
                        <label class="prompt-label">AUDIO FILE (REQUIRED)</label>
                    </div>
                    <div class="audio-upload-box" id="avatar-audio-box">
                        <input type="file" id="avatar-audio-input" accept="audio/*" style="display: none;">
                        <div class="audio-placeholder" id="audio-placeholder">
                            <span class="upload-text">Upload audio for lip-sync</span>
                        </div>
                        <div class="audio-preview" id="audio-preview" style="display: none;">
                            <audio id="avatar-audio-player" controls></audio>
                            <button class="remove-audio-btn" id="remove-avatar-audio"></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Resolution -->
            <div class="resolution-section">
                <label class="resolution-label">RESOLUTION</label>
                <select class="resolution-select" id="resolution">
                    <option value="auto">Auto</option>
                    <option value="1:1">Square (1:1)</option>
                    <option value="16:9">Landscape (16:9)</option>
                    <option value="9:16">Portrait (9:16)</option>
                    <option value="4:3">Standard (4:3)</option>
                    <option value="3:4">Standard Portrait (3:4)</option>
                </select>
            </div>

            <!-- Quality (Pro Mode Only) -->
            <div class="resolution-section" id="quality-section" style="display: none;">
                <label class="resolution-label">QUALITY (PRO ONLY)</label>
                <select class="resolution-select" id="quality">
                    <option value="4K">4K (Highest)</option>
                    <option value="2K">2K</option>
                    <option value="1K">1K (Fastest)</option>
                </select>
            </div>

            <!-- Generate Button -->
            <button class="generate-btn" id="generate-btn" {{ 'disabled' if not has_api_key else '' }}>
                GENERATE
            </button>

            <!-- Error Display -->
            <div class="error" id="error"></div>
            </div>
        </div>

        <div class="resizer" id="left-resizer"></div>

        <div class="output">
            <div class="output-header">OUTPUT</div>
            <div class="output-canvas" id="output-canvas">
                <!-- Top control bar with all controls -->
                <div class="output-top-bar">
                    <div class="zoom-controls" id="zoom-controls">
                        <button class="zoom-btn" id="zoom-out"></button>
                        <span class="zoom-level" id="zoom-level">100%</span>
                        <button class="zoom-btn" id="zoom-in">+</button>
                        <button class="zoom-btn" id="zoom-reset"></button>
                        <button class="zoom-btn compare-btn" id="compare-btn" title="Hold to compare with original" disabled>
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 3.99976H6C4.89543 3.99976 4 4.89519 4 5.99976V17.9998C4 19.1043 4.89543 19.9998 6 19.9998H13M17 3.99976H18C19.1046 3.99976 20 4.89519 20 5.99976V6.99976M20 16.9998V17.9998C20 19.1043 19.1046 19.9998 18 19.9998H17M20 10.9998V12.9998M12 1.99976V21.9998" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg>
                        </button>
                    </div>
                    <!-- Desktop: Undo/Redo in top bar -->
                    <div class="undo-redo-controls" id="undo-redo-controls">
                        <button class="undo-redo-btn" id="undo-btn" title="Undo" disabled>
                            <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 13C17.4904 11.9961 16.6247 11.1655 15.5334 10.6333C14.442 10.1011 13.1842 9.89624 11.9494 10.0495C9.93127 10.3 8.52468 11.6116 7 12.8186M7 10V13H10" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                        </button>
                        <button class="undo-redo-btn" id="redo-btn" title="Redo" disabled>
                            <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 13C6.50963 11.9961 7.37532 11.1655 8.46665 10.6333C9.55797 10.1011 10.8158 9.89624 12.0506 10.0495C14.0687 10.3 15.4753 11.6116 17 12.8186M17 10V13H14" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                        </button>
                    </div>
                    <button class="download-btn" id="download-btn">DOWNLOAD</button>
                    <button class="close-output" id="close-output" title="Clear View">&times;</button>
                </div>

                <!-- Image display area -->
                <div class="output-image-area">
                    <!-- Canvas Tools Sidebar (Edit Mode Only) -->
                    <div class="canvas-tools" id="canvas-tools">
                        <div class="brush-slider-container">
                            <span class="brush-size-label">SIZE</span>
                            <input type="range" class="brush-slider" id="brush-slider" min="5" max="100" value="30">
                            <span class="brush-size-value" id="brush-size-value">30</span>
                        </div>
                        <div class="canvas-tool-btns">
                            <button class="canvas-tool-btn active" id="brush-tool" title="Brush Tool">
                                <svg fill="#000000" width="24px" height="24px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M 19 2.03125 L 18.28125 2.71875 L 12.71875 8.3125 L 12 9 L 11 10 L 8.71875 12.3125 L 8.15625 12.875 L 8.59375 13.5625 C 8.59375 13.5625 9.203125 14.5 9.6875 15.53125 C 9.929688 16.046875 10.148438 16.59375 10.21875 16.96875 C 10.253906 17.15625 10.257813 17.269531 10.25 17.3125 C 10.140625 17.398438 8.824219 18.441406 7.25 19.71875 C 5.609375 21.046875 3.867188 22.445313 3.15625 23.15625 C 1.601563 24.710938 1.601563 27.257813 3.15625 28.8125 C 4.703125 30.359375 7.226563 30.347656 8.78125 28.8125 L 8.8125 28.8125 C 9.527344 28.097656 10.960938 26.382813 12.28125 24.75 C 13.570313 23.15625 14.65625 21.800781 14.71875 21.71875 C 14.714844 21.722656 14.761719 21.65625 15.125 21.71875 C 15.488281 21.78125 16.003906 21.96875 16.5 22.21875 C 17.492188 22.714844 18.40625 23.375 18.40625 23.375 L 19.09375 23.875 L 19.6875 23.28125 L 22 21 L 23 20 L 23.6875 19.28125 L 29.28125 13.71875 L 29.96875 13 L 29.28125 12.28125 L 19.71875 2.71875 Z M 20.3125 7.25 C 20.503906 7.265625 20.652344 7.339844 20.78125 7.46875 C 21.292969 7.984375 20.546875 9.988281 20.1875 10.84375 C 19.828125 11.703125 19.941406 12.375 20.40625 12.84375 C 21.199219 13.644531 23.296875 11.761719 24.1875 12.65625 C 25.074219 13.550781 23.460938 15.453125 24.03125 16.03125 C 24.042969 16.042969 24.050781 16.050781 24.0625 16.0625 L 22.28125 17.84375 L 14.15625 9.71875 L 15.53125 8.34375 C 15.550781 8.367188 15.570313 8.382813 15.59375 8.40625 C 16.273438 9.089844 17.667969 8.4375 18.25 8.0625 C 18.9375 7.621094 19.742188 7.203125 20.3125 7.25 Z M 12.71875 11.15625 L 20.84375 19.28125 L 20.5625 19.5625 L 18.84375 21.3125 C 18.457031 21.046875 18.1875 20.828125 17.40625 20.4375 C 16.808594 20.140625 16.160156 19.867188 15.46875 19.75 C 14.777344 19.632813 13.902344 19.660156 13.28125 20.28125 L 13.25 20.34375 L 13.21875 20.375 C 13.21875 20.375 12.039063 21.871094 10.71875 23.5 C 9.398438 25.128906 7.867188 26.945313 7.40625 27.40625 C 6.617188 28.195313 5.382813 28.195313 4.59375 27.40625 C 3.804688 26.617188 3.804688 25.382813 4.59375 24.59375 C 5.054688 24.132813 6.871094 22.601563 8.5 21.28125 C 10.128906 19.960938 11.625 18.78125 11.625 18.78125 L 11.65625 18.75 L 11.71875 18.71875 C 12.351563 18.089844 12.3125 17.253906 12.1875 16.59375 C 12.0625 15.933594 11.78125 15.289063 11.5 14.6875 C 11.121094 13.875 10.898438 13.578125 10.65625 13.1875 L 12.4375 11.4375 Z M 6.25 24.65625 C 5.644531 24.65625 5.15625 25.144531 5.15625 25.75 C 5.15625 26.355469 5.644531 26.84375 6.25 26.84375 C 6.855469 26.84375 7.34375 26.355469 7.34375 25.75 C 7.34375 25.144531 6.855469 24.65625 6.25 24.65625 Z"></path></svg>
                            </button>
                            <button class="canvas-tool-btn" id="move-tool" title="Move Tool">
                                <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V21M12 3L9 6M12 3L15 6M12 21L15 18M12 21L9 18M3 12H21M3 12L6 15M3 12L6 9M21 12L18 9M21 12L18 15" stroke="#000000" stroke-width="1.488" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                            </button>
                        </div>
                    </div>

                    <div class="output-placeholder" id="placeholder">Generated image appears here</div>
                    <div class="edit-mode-placeholder" id="edit-mode-placeholder">Upload an image to edit</div>
                    
                    <!-- Video Prompt Output -->
                    <div class="video-prompt-output" id="video-prompt-output">
                        <div class="prompt-output-header">
                            <span class="prompt-output-label">GENERATED VIDEO PROMPT</span>
                            <div class="prompt-output-actions">
                                <button class="copy-prompt-btn" id="copy-video-prompt">COPY</button>
                                <button class="close-prompt-output" id="close-prompt-output" title="Close">&times;</button>
                            </div>
                        </div>
                        <textarea class="prompt-output-text" id="video-prompt-text" placeholder="Generated prompt will appear here..."></textarea>
                        <button class="generate-video-btn" id="generate-video-btn">GENERATE VIDEO</button>
                    </div>
                    <!-- Video Container -->
                    <div class="video-container" id="video-container" style="display: none;">
                        <video id="output-video" controls loop playsinline></video>
                    </div>
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <span class="loading-text">GENERATING...</span>
                    </div>
                    <div class="image-container" id="image-container" style="display: none;">
                        <img id="output-image">
                    </div>
                    <!-- Edit Canvas Container -->
                    <div class="edit-canvas-container" id="edit-canvas-container">
                        <div class="edit-canvas-wrapper" id="edit-canvas-wrapper">
                            <img class="edit-base-image" id="edit-base-image">
                            <canvas class="edit-mask-canvas" id="edit-mask-canvas"></canvas>
                        </div>
                    </div>
                    <!-- Brush Size Preview Circle -->
                    <div class="brush-preview" id="brush-preview"></div>
                    <!-- Brush Cursor (follows mouse in edit mode) -->
                    <div class="brush-cursor" id="brush-cursor"></div>
                </div>
                <!-- Mobile: Undo/Redo at bottom -->
                <div class="mobile-undo-redo" id="mobile-undo-redo">
                    <button class="undo-redo-btn" id="mobile-undo-btn" title="Undo" disabled>
                        <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 13C17.4904 11.9961 16.6247 11.1655 15.5334 10.6333C14.442 10.1011 13.1842 9.89624 11.9494 10.0495C9.93127 10.3 8.52468 11.6116 7 12.8186M7 10V13H10" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </button>
                    <button class="undo-redo-btn" id="mobile-redo-btn" title="Redo" disabled>
                        <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 13C6.50963 11.9961 7.37532 11.1655 8.46665 10.6333C9.55797 10.1011 10.8158 9.89624 12.0506 10.0495C14.0687 10.3 15.4753 11.6116 17 12.8186M17 10V13H14" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="resizer" id="right-resizer"></div>

        <div class="history-panel" id="right-panel">
            <div class="panel-tabs">
                <button class="panel-tab active" data-tab="history">HISTORY</button>
                <button class="panel-tab" data-tab="saved">SAVED</button>
                <button class="clear-btn-header" id="clear-panel-btn">CLEAR</button>
            </div>
            <div class="history-list" id="history-list" style="display: flex;">
                <div class="history-empty" id="history-empty">No generations yet</div>
            </div>
            <div class="history-list" id="saved-list" style="display: none;">
                <div class="history-empty" id="saved-empty">No saved images</div>
            </div>
        </div>
    </main>

    <!-- Mobile Tab Bar (hidden on desktop) -->
    <nav class="mobile-tabs">
        <button class="mobile-tab active" data-panel="inputs">INPUT</button>
        <button class="mobile-tab" data-panel="output">OUTPUT</button>
        <button class="mobile-tab" data-panel="history">HISTORY</button>
    </nav>

    <!-- Image Lightbox -->
    <div class="lightbox-overlay" id="lightbox">
        <div class="lightbox-content">
            <img id="lightbox-image" src="" alt="Preview">
            <button class="lightbox-close" id="lightbox-close">&times;</button>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal">
            <div class="modal-title" id="modal-title">CLEAR DATA</div>
            <div class="modal-text" id="modal-text">Are you sure you want to delete all items? This action cannot be
                undone.</div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" onclick="closeModal()">CANCEL</button>
                <button class="modal-btn modal-btn-confirm" id="modal-confirm-btn">CLEAR ALL</button>
            </div>
        </div>
    </div>

    <script>
        // Resizable Panels
        const setupResizer = (resizerId, panelId, side) => {
            const resizer = document.getElementById(resizerId);
            const panel = document.getElementById(panelId);
            let startX, startWidth;

            resizer.addEventListener('mousedown', (e) => {
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                resizer.classList.add('resizing');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });

            const onMouseMove = (e) => {
                let newWidth;
                if (side === 'left') {
                    newWidth = startWidth + (e.clientX - startX);
                } else {
                    newWidth = startWidth - (e.clientX - startX);
                }

                if (newWidth >= 200 && newWidth <= 600) {
                    panel.style.width = `${newWidth}px`;
                }
            };

            const onMouseUp = () => {
                resizer.classList.remove('resizing');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.body.style.cursor = 'default';
            };
        };

        setupResizer('left-resizer', 'left-panel', 'left');
        setupResizer('right-resizer', 'right-panel', 'right');

        // State
        let referenceImages = [];  // Array of {id, dataUrl, traits}
        let editImage = null;
        let detectedTraits = '';  // Combined traits from all references
        let editTraits = '';
        let selectedRefAttributes = ['face', 'hair'];  // Default selected attributes
        let currentMode = 'draft';
        let currentResolution = 'auto';
        let currentQuality = '4K';
        let historyItems = [];
        let saved = [];
        let currentTab = 'history';
        let saveTimeout = null;
        let zoomLevel = 1;
        const ZOOM_STEP = 0.05;
        const ZOOM_MIN = 0.1;
        const ZOOM_MAX = 5;

        // Drag state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let startOffsetX = 0;
        let startOffsetY = 0;

        // Viewing state
        let viewingHistoryId = null;
        let isGenerating = false;
        let newIds = new Set();

        // New: Input mode state (prompt/edit/video)
        let currentInputMode = 'prompt';
        let currentModel = 'nano-banana';
        
        // Separate prompt state for image vs video modes
        let imagePrompt = '';  // Prompt for prompt/edit tabs
        let videoPrompt = '';  // Prompt for video tab
        
        // Video mode state
        let currentVideoModel = 'kling-2.6-i2v';
        let startFrameImage = null;
        let endFrameImage = null;
        let audioEnabled = true; // Audio toggle state (Kling 2.6 only)
        
        // Model-specific parameter state
        let gptBackground = 'auto';
        let gptOutputFormat = 'png';
        let gptInputFidelity = 'high';
        let nanoOutputFormat = 'png';
        let nanoProOutputFormat = 'png';
        let nanoProSeed = null;
        let nanoProWebSearch = false;
        let videoDuration = '5';
        let videoNegativePrompt = 'blur, distort, and low quality';
        let videoCfgScale = 0.5; // CFG scale for Kling 2.1/2.5 models (0-1)
        let motionCharOrientation = 'video';
        let motionKeepOriginalSound = true;
        let avatarAudioData = null; // Base64 audio data for Avatar lip-sync
        
        // Video character reference state (supports multiple images like prompt/edit tabs)
        let videoCharReferences = []; // Array of {id, dataUrl, traits}
        let combinedVideoCharTraits = ''; // Combined traits from all references
        let selectedVideoCharAttributes = ['face', 'hair']; // Default selected attributes

        // Canvas/Mask painting state
        let brushSize = 30;
        let currentCanvasTool = 'brush'; // 'brush' or 'move'
        let isDrawing = false;
        let maskCanvas = null;
        let maskCtx = null;
        let editCanvasZoom = 1;
        let editCanvasOffsetX = 0;
        let editCanvasOffsetY = 0;
        let editDragStartX = 0;
        let editDragStartY = 0;
        let editStartOffsetX = 0;
        let editStartOffsetY = 0;
        let isEditDragging = false;
        let editTouchStartDistance = 0;
        let editTouchStartZoom = 1;

        // Undo/Redo state
        let undoStack = [];
        let redoStack = [];
        let brushPreviewTimeout = null;

        // Track if last generation was from Edit Mode (for X button behavior)
        let generatedFromEditMode = false;
        let savedEditImageForReturn = null;
        let savedMaskDataForReturn = null;
        
        // Compare button state - stores the original edit image for comparison
        let compareOriginalImage = null;
        let compareGeneratedImage = null;

        // Prompt revert state
        let originalPromptBeforeEnhance = null;

        // SVG Icons
        const ICONS = {
            recreate: `<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><path d="M10 16.682l5.69 5.685 1.408-1.407-3.283-3.28h10.131c1.147 0 2.19.467 2.943 1.222a4.157 4.157 0 011.225 2.946 4.18 4.18 0 01-4.168 4.168h-5.628V28h5.522c3.387 0 6.16-2.77 6.16-6.157a6.117 6.117 0 00-1.81-4.343 6.143 6.143 0 00-4.35-1.805H13.815l3.283-3.285L15.69 11 10 16.682z" fill="currentColor" fill-rule="nonzero"></path></svg>`,
            download: `<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 666.5L367.2 521.7l36.2-36.2 83 83V256h51.2v312.5l83-83 36.2 36.2L512 666.5zm-204.8 50.3V768h409.6v-51.2H307.2z" fill="currentColor"></path></svg>`,
            save: `<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M665.6 768L512 614.4 358.4 768V256h307.2v512zM512 537.6L614.4 640V307.2H409.6V640L512 537.6z" fill="currentColor"></path></svg>`,
            saved: `<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M665.6 768L512 614.4 358.4 768V256h307.2v512z" fill="currentColor"></path></svg>`,
            delete: `<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M589 307v-51H435v51H307v51h410v-51M333 410v358h358V410H333zm102 307h-51V461h51v256zm103 0h-52V461h52v256zm102 0h-51V461h51v256z" fill="currentColor"></path></svg>`
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            // Check API/DB status
            try {
                const statusRes = await fetch('/api/status');
                const status = await statusRes.json();
                console.log('[VIEWR] System status:', status);
                
                // Log API key status
                if (status.has_api_key) {
                    console.log('[VIEWR]  API key connected');
                } else {
                    console.warn('[VIEWR]  No API key - generation will not work');
                }
                
                // Log database status
                if (!status.database) {
                    console.warn('[VIEWR]  Database not connected - historyItems will not persist');
                    if (status.database_uri_set) {
                        console.warn('[VIEWR] MONGODB_URI is set but connection failed. Check your connection string.');
                    } else {
                        console.warn('[VIEWR] MONGODB_URI not set in .env file');
                    }
                } else {
                    console.log('[VIEWR]  Database connected');
                }
            } catch (e) {
                console.error('[VIEWR] Failed to check status:', e);
            }

            await loadState();
            await refreshHistory();
            await refreshSaved();
            setupTabs();
            setupMobileTabs();
            setupInputModeToggle();
            setupModelSelector();
            setupCanvasTools();
            setupVideoMode();
            setupModelParams();
            updateModelOptions();
            updateModelParamsVisibility();
            updateStorageIndicator();
            
            // Setup Reset All buttons
            document.getElementById('reset-all-image').addEventListener('click', resetAllImage);
            document.getElementById('reset-all-video').addEventListener('click', resetAllVideo);
            updateResetButtonVisibility();
            
            // Ensure UI state matches restored state after all init
            updateInputModeUI();
        });

        // Storage indicator
        async function updateStorageIndicator() {
            try {
                const res = await fetch('/api/storage');
                const data = await res.json();
                if (data.success) {
                    const fill = document.getElementById('storage-fill');
                    const text = document.getElementById('storage-text');
                    const percent = data.percent;
                    
                    fill.style.width = `${Math.min(percent, 100)}%`;
                    fill.classList.remove('warning', 'critical');
                    if (percent >= 90) {
                        fill.classList.add('critical');
                    } else if (percent >= 70) {
                        fill.classList.add('warning');
                    }
                    
                    text.textContent = `${data.used_mb}MB`;
                    document.getElementById('storage-indicator').title = 
                        `Storage: ${data.used_mb}MB / ${data.limit_mb}MB (${percent}%)`;
                }
            } catch (e) {
                console.warn('[VIEWR] Failed to fetch storage:', e);
            }
        }

        // Mobile Tab Navigation
        let currentMobilePanel = 'inputs';

        function setupMobileTabs() {
            const mobileTabs = document.querySelectorAll('.mobile-tab');
            const panels = {
                inputs: document.getElementById('left-panel'),
                output: document.querySelector('.output'),
                history: document.getElementById('right-panel')
            };

            // Set initial active panel
            if (panels.inputs) panels.inputs.classList.add('mobile-active');

            mobileTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const panelName = tab.dataset.panel;
                    switchMobilePanel(panelName);
                });
            });
        }

        function switchMobilePanel(panelName) {
            const mobileTabs = document.querySelectorAll('.mobile-tab');
            const panels = {
                inputs: document.getElementById('left-panel'),
                output: document.querySelector('.output'),
                history: document.getElementById('right-panel')
            };

            // Update tab active state
            mobileTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.panel === panelName);
            });

            // Update panel visibility
            Object.keys(panels).forEach(key => {
                if (panels[key]) {
                    panels[key].classList.toggle('mobile-active', key === panelName);
                }
            });

            currentMobilePanel = panelName;
        }

        // Helper to check if on mobile
        function isMobileView() {
            return window.innerWidth <= 768 && window.matchMedia('(orientation: portrait)').matches;
        }

        // Tab switching (History/Saved within History panel)
        function setupTabs() {
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    currentTab = tab.dataset.tab;

                    document.getElementById('history-list').style.display = currentTab === 'history' ? 'flex' : 'none';
                    document.getElementById('saved-list').style.display = currentTab === 'saved' ? 'flex' : 'none';
                });
            });

            document.getElementById('clear-panel-btn').addEventListener('click', () => {
                if (currentTab === 'history') {
                    clearHistory();
                } else {
                    clearSaved();
                }
            });
        }

        // INPUT MODE TOGGLE (PROMPT / EDIT)
        function setupInputModeToggle() {
            document.querySelectorAll('.input-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const newMode = btn.dataset.inputMode;
                    const promptTextarea = document.getElementById('prompt');
                    const wasVideoMode = currentInputMode === 'video';
                    const isVideoMode = newMode === 'video';
                    
                    // Save current prompt to appropriate state variable before switching
                    if (wasVideoMode) {
                        videoPrompt = promptTextarea.value;
                    } else {
                        imagePrompt = promptTextarea.value;
                    }
                    
                    // Switch mode
                    document.querySelectorAll('.input-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentInputMode = newMode;
                    
                    // Restore the appropriate prompt for the new mode
                    if (isVideoMode) {
                        promptTextarea.value = videoPrompt;
                    } else {
                        promptTextarea.value = imagePrompt;
                    }
                    
                    updateInputModeUI();
                    updateModelParamsVisibility();
                });
            });
            
            // Setup enhance prompt button
            document.getElementById('enhance-prompt-btn').addEventListener('click', enhancePrompt);
            
            // Setup revert prompt button
            document.getElementById('revert-prompt-btn').addEventListener('click', revertPrompt);
        }
        
        // ENHANCE PROMPT using OpenRouter
        async function enhancePrompt() {
            const promptTextarea = document.getElementById('prompt');
            const enhanceBtn = document.getElementById('enhance-prompt-btn');
            const rawPrompt = promptTextarea.value.trim();
            
            if (!rawPrompt) {
                return;
            }
            
            // Store original prompt before enhancing
            originalPromptBeforeEnhance = rawPrompt;
            
            // Show loading state
            enhanceBtn.classList.add('loading');
            enhanceBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg> ENHANCING...';
            enhanceBtn.disabled = true;
            
            try {
                let response;
                let data;
                
                if (currentInputMode === 'video') {
                    // VIDEO MODE - Use video-specific enhancement
                    response = await fetch('/api/enhance-video-prompt', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: rawPrompt,
                            video_model: currentVideoModel,
                            start_frame: startFrameImage,
                            end_frame: endFrameImage,
                            audio_enabled: audioEnabled,
                            character_references: videoCharReferences.map(r => r.dataUrl),
                            character_traits: combinedVideoCharTraits,
                            character_attributes: selectedVideoCharAttributes
                        })
                    });
                    
                    data = await response.json();
                    
                    if (data.success && data.enhanced_prompt) {
                        promptTextarea.value = data.enhanced_prompt;
                        
                        // If negative prompt was returned, populate the negative prompt field
                        if (data.negative_prompt) {
                            const negativePromptInput = document.getElementById('video-negative-prompt');
                            if (negativePromptInput) {
                                negativePromptInput.value = data.negative_prompt;
                                videoNegativePrompt = data.negative_prompt;
                            }
                        }
                        
                        saveState();
                        // Show revert button after successful enhancement
                        document.getElementById('revert-prompt-btn').classList.add('visible');
                    } else {
                        console.error('[VIEWR] Video prompt enhancement failed:', data.error);
                        originalPromptBeforeEnhance = null;
                    }
                } else {
                    // IMAGE MODE - Use existing image enhancement
                    const isEditing = editImage !== null && editImage !== '';
                    
                    response = await fetch('/api/enhance-prompt', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: rawPrompt,
                            model: currentModel,
                            is_editing: isEditing,
                            edit_traits: isEditing ? editTraits : ''
                        })
                    });
                    
                    data = await response.json();
                    
                    if (data.success && data.enhanced_prompt) {
                        promptTextarea.value = data.enhanced_prompt;
                        saveState();
                        // Show revert button after successful enhancement
                        document.getElementById('revert-prompt-btn').classList.add('visible');
                    } else {
                        console.error('[VIEWR] Prompt enhancement failed:', data.error);
                        originalPromptBeforeEnhance = null;
                    }
                }
            } catch (e) {
                console.error('[VIEWR] Prompt enhancement error:', e);
                originalPromptBeforeEnhance = null;
            } finally {
                // Restore button state
                enhanceBtn.classList.remove('loading');
                enhanceBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg> ENHANCE';
                enhanceBtn.disabled = false;
            }
        }
        
        // Revert prompt to original before enhancement
        function revertPrompt() {
            if (originalPromptBeforeEnhance !== null) {
                const promptTextarea = document.getElementById('prompt');
                const revertBtn = document.getElementById('revert-prompt-btn');
                
                promptTextarea.value = originalPromptBeforeEnhance;
                originalPromptBeforeEnhance = null;
                revertBtn.classList.remove('visible');
                saveState();
            }
        }

        function updateInputModeUI() {
            const editBox = document.getElementById('edit-box');
            const optionalBadge = editBox.querySelector('.optional-badge');
            const placeholder = document.getElementById('placeholder');
            const editModePlaceholder = document.getElementById('edit-mode-placeholder');
            const canvasTools = document.getElementById('canvas-tools');
            const editCanvasContainer = document.getElementById('edit-canvas-container');
            const undoRedoControls = document.getElementById('undo-redo-controls');
            const mobileUndoRedo = document.getElementById('mobile-undo-redo');
            const zoomControls = document.getElementById('zoom-controls');
            const closeBtn = document.getElementById('close-output');
            
            // Video mode elements
            const modelSection = document.getElementById('model-section');
            const videoModelSection = document.getElementById('video-model-section');
            const videoFramesContainer = document.getElementById('video-frames-container');
            const referenceContainer = document.getElementById('reference-container');
            const refAttributes = document.getElementById('ref-attributes');
            const resolutionSection = document.querySelector('.resolution-section');
            const qualitySection = document.getElementById('quality-section');
            const enhanceBtn = document.getElementById('enhance-prompt-btn');
            const videoPromptOutput = document.getElementById('video-prompt-output');
            const imageContainer = document.getElementById('image-container');
            const modeToggle = document.querySelector('.header-right .mode-toggle');
            
            const editHeader = document.querySelector('.edit-header');
            
            if (currentInputMode === 'video') {
                // VIDEO MODE
                // Hide draft/pro toggle (use visibility to maintain header height)
                if (modeToggle) modeToggle.style.visibility = 'hidden';
                
                // Hide edit header in video mode
                if (editHeader) editHeader.style.display = 'none';
                
                // Hide image mode elements
                modelSection.style.display = 'none';
                referenceContainer.style.display = 'none';
                editBox.style.display = 'none';
                resolutionSection.style.display = 'none';
                qualitySection.style.display = 'none';
                enhanceBtn.style.display = 'flex';  // Show enhance button in video mode
                document.getElementById('traits-display').style.display = 'none';
                document.getElementById('edit-traits-display').style.display = 'none';
                
                // Show video mode elements
                videoModelSection.classList.add('visible');
                videoFramesContainer.classList.add('visible');
                
                // Hide edit mode elements
                editModePlaceholder.classList.remove('visible');
                canvasTools.classList.remove('visible');
                editCanvasContainer.classList.remove('visible');
                undoRedoControls.classList.remove('visible');
                mobileUndoRedo.classList.remove('visible');
                
                // Update output panel for video mode - no longer show video prompt output box
                videoPromptOutput.classList.remove('visible');
                if (!viewingHistoryId && !isGenerating) {
                    placeholder.style.display = 'block';
                    placeholder.textContent = 'Generated video appears here';
                    imageContainer.style.display = 'none';
                }
                
                // Update end frame availability based on model
                updateEndFrameAvailability();
                updateAudioToggleVisibility();
                
            } else if (currentInputMode === 'edit') {
                // EDIT MODE
                // Show draft/pro toggle
                if (modeToggle) modeToggle.style.visibility = 'visible';
                
                // Show edit header
                if (editHeader) editHeader.style.display = 'flex';
                
                // Hide audio toggle
                document.getElementById('audio-toggle-section').classList.remove('visible');
                
                // Show image mode elements
                modelSection.style.display = 'flex';
                referenceContainer.style.display = 'flex';
                editBox.style.display = 'flex';
                resolutionSection.style.display = 'flex';
                qualitySection.style.display = (currentMode === 'pro') ? 'flex' : 'none';
                enhanceBtn.style.display = 'flex';
                
                // Show/hide traits displays based on whether traits exist (same as prompt mode)
                document.getElementById('traits-display').style.display = detectedTraits ? 'block' : 'none';
                document.getElementById('edit-traits-display').style.display = editTraits ? 'block' : 'none';
                
                // Hide video mode elements
                videoModelSection.classList.remove('visible');
                videoFramesContainer.classList.remove('visible');
                videoPromptOutput.classList.remove('visible');
                
                if (optionalBadge) optionalBadge.style.display = 'none';
                if (!editImage) {
                    placeholder.style.display = 'none';
                    placeholder.textContent = 'Generated image appears here';
                    editModePlaceholder.classList.add('visible');
                    canvasTools.classList.remove('visible');
                    editCanvasContainer.classList.remove('visible');
                    undoRedoControls.classList.remove('visible');
                    mobileUndoRedo.classList.remove('visible');
                    zoomControls.classList.remove('visible');
                    closeBtn.classList.remove('visible');
                } else {
                    placeholder.style.display = 'none';
                    editModePlaceholder.classList.remove('visible');
                    canvasTools.classList.add('visible');
                    undoRedoControls.classList.add('visible');
                    mobileUndoRedo.classList.add('visible');
                    zoomControls.classList.add('visible');
                    closeBtn.classList.add('visible');
                    showEditCanvas(editImage);
                }
            } else {
                // PROMPT MODE
                // Show draft/pro toggle
                if (modeToggle) modeToggle.style.visibility = 'visible';
                
                // Show edit header
                if (editHeader) editHeader.style.display = 'flex';
                
                // Hide audio toggle
                document.getElementById('audio-toggle-section').classList.remove('visible');
                
                // Show image mode elements
                modelSection.style.display = 'flex';
                referenceContainer.style.display = 'flex';
                editBox.style.display = 'flex';
                resolutionSection.style.display = 'flex';
                qualitySection.style.display = (currentMode === 'pro') ? 'flex' : 'none';
                enhanceBtn.style.display = 'flex';
                document.getElementById('traits-display').style.display = detectedTraits ? 'block' : 'none';
                document.getElementById('edit-traits-display').style.display = editTraits ? 'block' : 'none';
                
                // Hide video mode elements
                videoModelSection.classList.remove('visible');
                videoFramesContainer.classList.remove('visible');
                videoPromptOutput.classList.remove('visible');
                
                if (optionalBadge) optionalBadge.style.display = 'block';
                editModePlaceholder.classList.remove('visible');
                canvasTools.classList.remove('visible');
                editCanvasContainer.classList.remove('visible');
                undoRedoControls.classList.remove('visible');
                mobileUndoRedo.classList.remove('visible');
                if (!viewingHistoryId && !isGenerating) {
                    placeholder.style.display = 'block';
                    placeholder.textContent = 'Generated image appears here';
                }
            }
        }
        
        // VIDEO MODE FUNCTIONS
        function updateAudioToggleVisibility() {
            const audioToggleSection = document.getElementById('audio-toggle-section');
            const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
            // Only show audio toggle in video mode when model supports audio
            if (currentInputMode === 'video' && capabilities.audio) {
                audioToggleSection.classList.add('visible');
            } else {
                audioToggleSection.classList.remove('visible');
            }
        }
        
        // Video model capabilities matrix (must match backend VIDEO_MODEL_CAPABILITIES)
        // cfg_scale: supports CFG scale parameter (0-1) for Kling 2.1/2.5
        // extended_duration: supports 3-10s duration (O1 models)
        // uses_image_url: uses 'image_url' instead of 'start_image_url'
        // uses_tail_image_url: uses 'tail_image_url' instead of 'end_image_url'
        const VIDEO_MODEL_CAPABILITIES = {
            // Kling 2.6 Pro - uses start_image_url, end_image_url
            "kling-2.6-i2v": { start_frame: true, end_frame: true, audio: true, text_to_video: false },
            "kling-2.6-t2v": { start_frame: false, end_frame: false, audio: true, text_to_video: true, aspect_ratio: true },
            "kling-2.6-motion": { start_frame: true, end_frame: false, audio: false, text_to_video: false, motion_video: true },
            // Kling 2.5 Turbo Pro - uses image_url, tail_image_url, supports cfg_scale
            "kling-2.5-pro-i2v": { start_frame: true, end_frame: true, audio: false, text_to_video: false, cfg_scale: true, uses_image_url: true, uses_tail_image_url: true },
            "kling-2.5-pro-t2v": { start_frame: false, end_frame: false, audio: false, text_to_video: true, cfg_scale: true },
            "kling-2.5-std-i2v": { start_frame: true, end_frame: false, audio: false, text_to_video: false, cfg_scale: true, uses_image_url: true },
            // Kling 2.1 Master/Pro - uses image_url, supports cfg_scale
            "kling-2.1-master-i2v": { start_frame: true, end_frame: false, audio: false, text_to_video: false, cfg_scale: true, uses_image_url: true },
            "kling-2.1-master-t2v": { start_frame: false, end_frame: false, audio: false, text_to_video: true, cfg_scale: true },
            "kling-2.1-pro-i2v": { start_frame: true, end_frame: true, audio: false, text_to_video: false, cfg_scale: true, uses_image_url: true },
            // Kling O1 - uses start_image_url, end_image_url, extended duration 3-10s
            "kling-o1-pro-i2v": { start_frame: true, end_frame: true, audio: false, text_to_video: false, extended_duration: true },
            "kling-o1-pro-v2v": { video_reference: true, end_frame: false, audio: false, text_to_video: false, video_to_video: true, extended_duration: true },
            "kling-o1-std-i2v": { start_frame: true, end_frame: true, audio: false, text_to_video: false, extended_duration: true },
            "kling-o1-std-v2v": { video_reference: true, end_frame: false, audio: false, text_to_video: false, video_to_video: true, extended_duration: true },
            // Kling AI Avatar - requires audio_url for lip-sync
            "kling-avatar": { start_frame: true, end_frame: false, audio: false, text_to_video: false, avatar: true, uses_image_url: true, requires_audio: true },
        };
        
        function updateEndFrameAvailability() {
            const endFrameBox = document.getElementById('end-frame-box');
            const endFrameWrapper = document.getElementById('end-frame-wrapper');
            const startFrameBox = document.getElementById('start-frame-box');
            const startFrameWrapper = document.getElementById('start-frame-wrapper');
            const startFrameLabel = document.getElementById('start-frame-label');
            const startFrameInput = document.getElementById('start-frame-input');
            const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
            
            // Handle start frame / video reference visibility and labeling
            if (capabilities.video_to_video) {
                // Video-to-video mode: accept video files, change label
                startFrameBox.classList.remove('disabled');
                if (startFrameWrapper) startFrameWrapper.classList.remove('disabled');
                if (startFrameLabel) startFrameLabel.textContent = 'VIDEO REFERENCE';
                startFrameBox.querySelector('.frame-hint').textContent = 'Source video to transform';
                startFrameInput.accept = 'video/*';
            } else if (capabilities.text_to_video) {
                startFrameBox.classList.add('disabled');
                if (startFrameWrapper) startFrameWrapper.classList.add('disabled');
                if (startFrameLabel) startFrameLabel.textContent = 'START FRAME';
                startFrameBox.querySelector('.frame-hint').textContent = 'Not needed for text-to-video';
                startFrameInput.accept = 'image/*';
            } else {
                // Image-to-video mode: accept image files
                startFrameBox.classList.remove('disabled');
                if (startFrameWrapper) startFrameWrapper.classList.remove('disabled');
                if (startFrameLabel) startFrameLabel.textContent = 'START FRAME';
                startFrameBox.querySelector('.frame-hint').textContent = 'Opening shot';
                startFrameInput.accept = 'image/*';
            }
            
            // Handle end frame visibility
            const endFrameOptionalBadge = endFrameBox.querySelector('.optional-badge');
            if (!capabilities.end_frame) {
                endFrameBox.classList.add('disabled');
                if (endFrameWrapper) endFrameWrapper.classList.add('disabled');
                if (endFrameOptionalBadge) endFrameOptionalBadge.style.display = 'none';
                if (capabilities.text_to_video) {
                    endFrameBox.querySelector('.frame-hint').textContent = 'Not available for text-to-video';
                } else if (capabilities.motion_video) {
                    endFrameBox.querySelector('.frame-hint').textContent = 'Use motion video instead';
                } else if (capabilities.video_to_video) {
                    endFrameBox.querySelector('.frame-hint').textContent = 'Not available for video-to-video';
                } else {
                    endFrameBox.querySelector('.frame-hint').textContent = 'Not supported by this model';
                }
            } else {
                endFrameBox.classList.remove('disabled');
                if (endFrameWrapper) endFrameWrapper.classList.remove('disabled');
                if (endFrameOptionalBadge) endFrameOptionalBadge.style.display = '';
                endFrameBox.querySelector('.frame-hint').textContent = 'Closing shot';
            }
            
            // Update motion video section visibility (for Kling 2.6 Motion Control)
            updateMotionVideoVisibility();
            
            // Update video character reference availability (disabled for text-to-video)
            const videoCharBox = document.getElementById('add-video-char-box');
            const videoCharSection = document.getElementById('video-char-reference');
            if (videoCharBox) {
                if (capabilities.text_to_video) {
                    videoCharBox.classList.add('disabled');
                    if (videoCharSection) videoCharSection.classList.add('disabled');
                } else {
                    videoCharBox.classList.remove('disabled');
                    if (videoCharSection) videoCharSection.classList.remove('disabled');
                }
            }
        }
        
        function updateMotionVideoVisibility() {
            const motionSection = document.getElementById('motion-video-section');
            if (!motionSection) return;
            
            const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
            if (capabilities.motion_video) {
                motionSection.style.display = 'block';
            } else {
                motionSection.style.display = 'none';
            }
        }
        
        // Setup model-specific parameter controls
        function setupModelParams() {
            // GPT Image 1.5 params
            document.getElementById('gpt-background').addEventListener('change', (e) => {
                gptBackground = e.target.value;
            });
            document.getElementById('gpt-output-format').addEventListener('change', (e) => {
                gptOutputFormat = e.target.value;
            });
            document.getElementById('gpt-input-fidelity').addEventListener('change', (e) => {
                gptInputFidelity = e.target.value;
            });
            
            // Nano Banana params
            document.getElementById('nano-output-format').addEventListener('change', (e) => {
                nanoOutputFormat = e.target.value;
            });
            
            // Nano Banana Pro params
            document.getElementById('nano-pro-output-format').addEventListener('change', (e) => {
                nanoProOutputFormat = e.target.value;
            });
            
            // Seed input with validation
            const seedInput = document.getElementById('nano-pro-seed');
            seedInput.addEventListener('input', (e) => {
                // Allow only digits, empty, or "Random"
                const val = e.target.value;
                if (val === '' || val.toLowerCase() === 'random') {
                    nanoProSeed = null;
                    seedInput.classList.remove('has-value');
                } else {
                    const parsed = parseInt(val.replace(/[^0-9]/g, ''));
                    if (!isNaN(parsed) && parsed >= 0) {
                        nanoProSeed = parsed;
                        e.target.value = parsed; // Clean the input
                        seedInput.classList.add('has-value');
                    }
                }
            });
            seedInput.addEventListener('blur', (e) => {
                // Format on blur
                if (e.target.value === '' || e.target.value.toLowerCase() === 'random') {
                    e.target.value = '';
                    e.target.placeholder = 'Random';
                    nanoProSeed = null;
                    seedInput.classList.remove('has-value');
                }
            });
            
            // Random seed button - generates positive integer (1 to 2147483647)
            
            // Web search toggle
            document.getElementById('web-search-off').addEventListener('click', () => {
                nanoProWebSearch = false;
                document.getElementById('web-search-off').classList.add('active');
                document.getElementById('web-search-on').classList.remove('active');
            });
            document.getElementById('web-search-on').addEventListener('click', () => {
                nanoProWebSearch = true;
                document.getElementById('web-search-on').classList.add('active');
                document.getElementById('web-search-off').classList.remove('active');
            });
            
            // Video params
            document.getElementById('video-duration').addEventListener('change', (e) => {
                videoDuration = e.target.value;
            });
            document.getElementById('video-negative-prompt').addEventListener('change', (e) => {
                videoNegativePrompt = e.target.value;
            });
            document.getElementById('video-cfg-scale').addEventListener('input', (e) => {
                videoCfgScale = parseFloat(e.target.value);
                document.getElementById('cfg-scale-value').textContent = videoCfgScale.toFixed(1);
            });
            
            // Motion control params
            document.getElementById('motion-char-orientation').addEventListener('change', (e) => {
                motionCharOrientation = e.target.value;
            });
            
            // Keep original sound toggle
            document.getElementById('keep-sound-off').addEventListener('click', () => {
                motionKeepOriginalSound = false;
                document.getElementById('keep-sound-off').classList.add('active');
                document.getElementById('keep-sound-on').classList.remove('active');
            });
            document.getElementById('keep-sound-on').addEventListener('click', () => {
                motionKeepOriginalSound = true;
                document.getElementById('keep-sound-on').classList.add('active');
                document.getElementById('keep-sound-off').classList.remove('active');
            });
        }
        
        function setupVideoMode() {
            // Video model selector
            document.getElementById('video-model-select').addEventListener('change', (e) => {
                currentVideoModel = e.target.value;
                updateEndFrameAvailability();
                updateAudioToggleVisibility();
                updateModelParamsVisibility();
            });
            
            // Audio toggle buttons
            document.querySelectorAll('.audio-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.audio-toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    audioEnabled = btn.dataset.audio === 'on';
                });
            });
            
            // Start frame upload
            const startFrameBox = document.getElementById('start-frame-box');
            const startFrameInput = document.getElementById('start-frame-input');
            startFrameBox.addEventListener('click', (e) => {
                if (e.target.closest('.clear-frame-btn')) return;
                if (startFrameBox.classList.contains('disabled')) return;
                if (startFrameImage && startFrameBox.classList.contains('has-image')) {
                    showLightbox(startFrameImage);
                    return;
                }
                startFrameInput.click();
            });
            startFrameInput.addEventListener('change', (e) => handleVideoFrameUpload(e, 'start'));
            
            // Drag and drop for start frame
            startFrameBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (startFrameBox.classList.contains('disabled')) return;
                startFrameBox.classList.add('dragover');
            });
            startFrameBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startFrameBox.classList.remove('dragover');
            });
            startFrameBox.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                startFrameBox.classList.remove('dragover');
                if (startFrameBox.classList.contains('disabled')) return;
                const file = e.dataTransfer.files[0];
                const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
                const acceptVideo = capabilities.video_to_video;
                const isVideoFile = file && file.type.startsWith('video/');
                const isImageFile = file && file.type.startsWith('image/');
                
                if (file && ((acceptVideo && isVideoFile) || (!acceptVideo && isImageFile))) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        startFrameImage = ev.target.result;
                        updateVideoFramePreview('start', ev.target.result, isVideoFile);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // End frame upload
            const endFrameBox = document.getElementById('end-frame-box');
            const endFrameInput = document.getElementById('end-frame-input');
            endFrameBox.addEventListener('click', (e) => {
                if (e.target.closest('.clear-frame-btn')) return;
                if (endFrameImage && endFrameBox.classList.contains('has-image')) {
                    showLightbox(endFrameImage);
                    return;
                }
                if (!endFrameBox.classList.contains('disabled')) {
                    endFrameInput.click();
                }
            });
            endFrameInput.addEventListener('change', (e) => handleVideoFrameUpload(e, 'end'));
            
            // Drag and drop for end frame
            endFrameBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (endFrameBox.classList.contains('disabled')) return;
                endFrameBox.classList.add('dragover');
            });
            endFrameBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                endFrameBox.classList.remove('dragover');
            });
            endFrameBox.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                endFrameBox.classList.remove('dragover');
                if (endFrameBox.classList.contains('disabled')) return;
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        endFrameImage = ev.target.result;
                        updateVideoFramePreview('end', ev.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Avatar audio upload
            const avatarAudioBox = document.getElementById('avatar-audio-box');
            const avatarAudioInput = document.getElementById('avatar-audio-input');
            avatarAudioBox.addEventListener('click', (e) => {
                if (e.target.closest('.remove-audio-btn')) return;
                if (!avatarAudioData) {
                    avatarAudioInput.click();
                }
            });
            avatarAudioInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    avatarAudioData = ev.target.result;
                    document.getElementById('audio-placeholder').style.display = 'none';
                    document.getElementById('audio-preview').style.display = 'flex';
                    document.getElementById('avatar-audio-player').src = avatarAudioData;
                };
                reader.readAsDataURL(file);
            });
            document.getElementById('remove-avatar-audio').addEventListener('click', (e) => {
                e.stopPropagation();
                avatarAudioData = null;
                avatarAudioInput.value = '';
                document.getElementById('audio-placeholder').style.display = 'flex';
                document.getElementById('audio-preview').style.display = 'none';
                document.getElementById('avatar-audio-player').src = '';
            });
            
            // Copy video prompt button
            document.getElementById('copy-video-prompt').addEventListener('click', async () => {
                const textarea = document.getElementById('video-prompt-text');
                const promptText = textarea.value;
                const btn = document.getElementById('copy-video-prompt');
                
                try {
                    // Use ClipboardItem API to explicitly set plain text format
                    // This prevents browsers from auto-detecting and converting to URL format
                    const blob = new Blob([promptText], { type: 'text/plain' });
                    const clipboardItem = new ClipboardItem({ 'text/plain': blob });
                    await navigator.clipboard.write([clipboardItem]);
                    btn.textContent = 'COPIED!';
                    setTimeout(() => btn.textContent = 'COPY', 2000);
                } catch (err) {
                    // Fallback: try writeText first
                    try {
                        await navigator.clipboard.writeText(promptText);
                        btn.textContent = 'COPIED!';
                        setTimeout(() => btn.textContent = 'COPY', 2000);
                    } catch (err2) {
                        // Final fallback: select and copy from textarea
                        textarea.select();
                        textarea.setSelectionRange(0, 99999);
                        document.execCommand('copy');
                        btn.textContent = 'COPIED!';
                        setTimeout(() => btn.textContent = 'COPY', 2000);
                    }
                }
            });
            
            // Close video prompt output button
            document.getElementById('close-prompt-output').addEventListener('click', () => {
                document.getElementById('video-prompt-output').classList.remove('visible');
                document.getElementById('video-container').style.display = 'none';
                document.getElementById('placeholder').style.display = 'block';
                document.getElementById('placeholder').textContent = 'Generated video appears here';
                document.getElementById('video-prompt-text').value = '';
            });
            
            // Video character reference setup
            setupVideoCharReference();
        }
        
        // Setup video character reference (supports multiple images)
        function setupVideoCharReference() {
            const addBox = document.getElementById('add-video-char-box');
            const input = document.getElementById('video-char-input');
            const clearBtn = document.getElementById('clear-video-char-ref');
            const grid = document.getElementById('video-char-grid');
            const attributesSection = document.getElementById('video-char-attributes');
            const traitsDisplay = document.getElementById('video-char-traits-display');
            
            // Click to upload
            addBox.addEventListener('click', () => {
                if (addBox.classList.contains('disabled')) return;
                input.click();
            });
            
            // File input change - support multiple files
            input.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => {
                    if (file && file.type.startsWith('image/')) {
                        handleVideoCharUpload(file);
                    }
                });
                input.value = ''; // Reset for re-upload of same file
            });
            
            // Drag and drop on add box
            addBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (addBox.classList.contains('disabled')) return;
                addBox.classList.add('dragover');
            });
            addBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
            });
            addBox.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
                if (addBox.classList.contains('disabled')) return;
                const files = Array.from(e.dataTransfer.files);
                files.forEach(file => {
                    if (file && file.type.startsWith('image/')) {
                        handleVideoCharUpload(file);
                    }
                });
            });
            
            // Drag and drop on grid
            grid.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.add('dragover');
            });
            grid.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
            });
            grid.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                files.forEach(file => {
                    if (file && file.type.startsWith('image/')) {
                        handleVideoCharUpload(file);
                    }
                });
            });
            
            // Clear button
            clearBtn.addEventListener('click', () => {
                clearAllVideoCharReferences();
            });
            
            // Attribute buttons
            document.querySelectorAll('#video-char-attributes .ref-attr-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    selectedVideoCharAttributes = Array.from(
                        document.querySelectorAll('#video-char-attributes .ref-attr-btn.active')
                    ).map(b => b.dataset.attr);
                });
            });
        }
        
        // Handle video character reference upload (add to array)
        async function handleVideoCharUpload(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const dataUrl = e.target.result;
                const newRef = {
                    id: 'video_char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    dataUrl: dataUrl,
                    traits: ''
                };
                videoCharReferences.push(newRef);
                renderVideoCharGrid();
                
                // Analyze the character reference image
                await analyzeVideoCharReference(newRef);
            };
            reader.readAsDataURL(file);
        }
        
        // Analyze video character reference for traits
        async function analyzeVideoCharReference(refObj) {
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: refObj.dataUrl })
                });
                const data = await response.json();
                if (data.success && data.traits) {
                    // Update traits on the reference object
                    const ref = videoCharReferences.find(r => r.id === refObj.id);
                    if (ref) {
                        ref.traits = data.traits;
                    }
                    // Update combined traits display
                    updateCombinedVideoCharTraits();
                }
            } catch (err) {
                console.error('[VIEWR] Failed to analyze video character reference:', err);
            }
        }
        
        // Update combined traits from all video character references
        function updateCombinedVideoCharTraits() {
            const allTraits = videoCharReferences.map(r => r.traits).filter(t => t).join('\n\n');
            combinedVideoCharTraits = allTraits;
            const traitsDisplay = document.getElementById('video-char-traits-display');
            if (videoCharReferences.length > 0) {
                document.getElementById('video-char-traits-text').textContent = allTraits || '(analyzing...)';
                traitsDisplay.style.display = 'block';
            } else {
                document.getElementById('video-char-traits-text').textContent = '';
                traitsDisplay.style.display = 'none';
            }
        }
        
        // Render video character reference grid (multiple images)
        function renderVideoCharGrid() {
            const grid = document.getElementById('video-char-grid');
            const clearBtn = document.getElementById('clear-video-char-ref');
            const attributesSection = document.getElementById('video-char-attributes');
            const addBox = document.getElementById('add-video-char-box');
            
            // Clear existing items except add box
            grid.querySelectorAll('.reference-item').forEach(item => item.remove());
            
            if (videoCharReferences.length > 0) {
                // Show clear button and attributes
                clearBtn.style.display = 'block';
                attributesSection.style.display = 'block';
                grid.classList.add('has-images');
                
                // Create reference items for each image
                videoCharReferences.forEach(ref => {
                    const item = document.createElement('div');
                    item.className = 'reference-item';
                    item.dataset.refId = ref.id;
                    item.innerHTML = `
                        <img src="${ref.dataUrl}" alt="Character Reference">
                        <button class="remove-btn">&times;</button>
                    `;
                    
                    // Click to view in lightbox
                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('remove-btn')) {
                            showLightbox(ref.dataUrl);
                        }
                    });
                    
                    // Remove button
                    item.querySelector('.remove-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeVideoCharReference(ref.id);
                    });
                    
                    grid.insertBefore(item, addBox);
                });
                
                // Always show add box for adding more
                addBox.style.display = 'flex';
            } else {
                // Show add box, hide clear button and attributes
                addBox.style.display = 'flex';
                clearBtn.style.display = 'none';
                attributesSection.style.display = 'none';
                grid.classList.remove('has-images');
                document.getElementById('video-char-traits-display').style.display = 'none';
            }
        }
        
        // Remove a single video character reference
        function removeVideoCharReference(refId) {
            videoCharReferences = videoCharReferences.filter(r => r.id !== refId);
            updateCombinedVideoCharTraits();
            renderVideoCharGrid();
        }
        
        // Clear all video character references
        function clearAllVideoCharReferences() {
            videoCharReferences = [];
            combinedVideoCharTraits = '';
            document.getElementById('video-char-input').value = '';
            updateCombinedVideoCharTraits();
            renderVideoCharGrid();
        }
        
        // Legacy function name for backwards compatibility
        function clearVideoCharReference() {
            clearAllVideoCharReferences();
        }
        
        function handleVideoFrameUpload(event, frameType) {
            const file = event.target.files[0];
            if (!file) return;
            
            const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
            const isVideoFile = file.type.startsWith('video/');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                if (frameType === 'start') {
                    startFrameImage = dataUrl;
                    updateVideoFramePreview('start', dataUrl, isVideoFile);
                } else {
                    endFrameImage = dataUrl;
                    updateVideoFramePreview('end', dataUrl, isVideoFile);
                }
            };
            reader.readAsDataURL(file);
        }
        
        function updateVideoFramePreview(frameType, dataUrl, isVideo = false) {
            const box = document.getElementById(`${frameType}-frame-box`);
            
            // Remove existing preview if any
            const existingPreview = box.querySelector('.frame-preview');
            const existingVideoPreview = box.querySelector('.video-frame-preview');
            if (existingPreview) existingPreview.remove();
            if (existingVideoPreview) existingVideoPreview.remove();
            
            if (dataUrl) {
                if (isVideo) {
                    // Add video preview
                    const video = document.createElement('video');
                    video.className = 'video-frame-preview';
                    video.src = dataUrl;
                    video.muted = true;
                    video.loop = true;
                    video.autoplay = true;
                    video.playsInline = true;
                    box.appendChild(video);
                } else {
                    // Add image preview
                    const img = document.createElement('img');
                    img.className = 'frame-preview';
                    img.src = dataUrl;
                    box.appendChild(img);
                }
                box.classList.add('has-image');
            } else {
                box.classList.remove('has-image');
            }
        }
        
        function clearVideoFrame(frameType) {
            if (frameType === 'start') {
                startFrameImage = null;
                document.getElementById('start-frame-input').value = '';
            } else {
                endFrameImage = null;
                document.getElementById('end-frame-input').value = '';
            }
            updateVideoFramePreview(frameType, null);
        }
        
        // Generate video directly from the prompt input
        async function generateVideoDirectly() {
            const videoPrompt = document.getElementById('prompt').value.trim();
            
            if (!videoPrompt) {
                showError('Enter a description for your video.');
                return;
            }
            
            const btn = document.getElementById('generate-btn');
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            const videoContainer = document.getElementById('video-container');
            const outputVideo = document.getElementById('output-video');
            const placeholder = document.getElementById('placeholder');
            
            isGenerating = true;
            btn.disabled = true;
            btn.textContent = 'GENERATING...';
            error.classList.remove('visible');
            loading.classList.add('visible');
            placeholder.style.display = 'none';
            
            // Switch to OUTPUT tab on mobile
            if (isMobileView()) {
                switchMobilePanel('output');
            }
            
            // Hide video prompt output if visible
            document.getElementById('video-prompt-output').classList.remove('visible');
            
            try {
                const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
                
                const payload = {
                    prompt: videoPrompt,
                    video_model: currentVideoModel,
                    duration: videoDuration,
                    aspect_ratio: '16:9',
                    audio_enabled: capabilities.audio ? audioEnabled : false,
                    negative_prompt: videoNegativePrompt
                };
                
                // Add motion control params if applicable
                if (capabilities.motion_video) {
                    payload.character_orientation = motionCharOrientation;
                    payload.keep_original_sound = motionKeepOriginalSound;
                }
                
                // Add cfg_scale for models that support it (Kling 2.1/2.5)
                if (capabilities.cfg_scale) {
                    payload.cfg_scale = videoCfgScale;
                }
                
                // Add start frame if model supports it
                if (startFrameImage && capabilities.start_frame) {
                    payload.start_frame = startFrameImage;
                }
                
                // Add end frame if model supports it
                if (endFrameImage && capabilities.end_frame) {
                    payload.end_frame = endFrameImage;
                }
                
                // Add character references if model supports it
                if (videoCharReferences.length > 0 && capabilities.reference) {
                    payload.character_references = videoCharReferences.map(r => r.dataUrl);
                }
                
                // Add avatar audio for lip-sync models
                if (capabilities.avatar && capabilities.requires_audio) {
                    if (!avatarAudioData) {
                        showError('Audio file is required for Avatar lip-sync');
                        generateBtn.disabled = false;
                        generateBtn.textContent = 'GENERATE';
                        return;
                    }
                    payload.avatar_audio = avatarAudioData;
                }
                
                console.log('[VIEWR] Generating video directly with model:', currentVideoModel);
                
                const response = await fetch('/api/generate-video', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                console.log('[VIEWR] Video generation response:', data);
                
                if (data.success && data.video_url) {
                    // Capture old history IDs before refresh
                    const oldHistoryIds = new Set(historyItems.map(item => item.id));
                    
                    // Show video in output
                    outputVideo.src = data.video_url;
                    videoContainer.style.display = 'block';
                    document.getElementById('placeholder').style.display = 'none';
                    document.getElementById('image-container').style.display = 'none';
                    
                    // Show controls for video
                    document.getElementById('download-btn').classList.add('visible');
                    document.getElementById('close-output').classList.add('visible');
                    
                    // Refresh history and mark new items
                    await refreshHistory();
                    
                    historyItems.forEach(item => {
                        if (!oldHistoryIds.has(item.id)) {
                            newIds.add(item.id);
                            console.log('[VIEWR] New video added to history:', item.id);
                        }
                    });
                    
                    renderHistory();
                    
                    // Auto-switch to OUTPUT tab on mobile
                    if (isMobileView()) {
                        switchMobilePanel('output');
                    }
                } else {
                    showError(data.error || 'Failed to generate video.');
                    placeholder.style.display = 'block';
                    placeholder.textContent = 'Video generation failed';
                }
            } catch (e) {
                console.error('[VIEWR] Video generation error:', e);
                showError('Video generation failed. Check your connection.');
                placeholder.style.display = 'block';
            } finally {
                isGenerating = false;
                btn.disabled = false;
                btn.textContent = 'GENERATE';
                loading.classList.remove('visible');
            }
        }
        
        // Get human-readable label for video model
        function getVideoModelLabel(modelKey) {
            const labels = {
                'kling-2.6-i2v': 'KLING 2.6 I2V',
                'kling-2.6-t2v': 'KLING 2.6 T2V',
                'kling-2.6-motion': 'KLING 2.6 MOTION',
                'kling-2.5-pro-i2v': 'KLING 2.5 PRO',
                'kling-2.5-pro-t2v': 'KLING 2.5 T2V',
                'kling-2.5-std-i2v': 'KLING 2.5 STD',
                'kling-2.1-master-i2v': 'KLING 2.1 MASTER',
                'kling-2.1-master-t2v': 'KLING 2.1 T2V',
                'kling-2.1-pro-i2v': 'KLING 2.1 PRO',
                'kling-o1-pro-i2v': 'KLING O1 PRO',
                'kling-o1-pro-v2v': 'KLING O1 V2V',
                'kling-o1-std-i2v': 'KLING O1 STD',
                'kling-o1-std-v2v': 'KLING O1 STD V2V'
            };
            return labels[modelKey] || modelKey?.toUpperCase() || 'KLING';
        }
        
        // Load generated video from history into output
        function loadVideoFromHistory(item) {
            const videoContainer = document.getElementById('video-container');
            const outputVideo = document.getElementById('output-video');
            const imageContainer = document.getElementById('image-container');
            const zoomControls = document.getElementById('zoom-controls');
            
            // Track which item is being viewed
            viewingHistoryId = item.id;
            
            // Stop and reset any currently playing video first
            outputVideo.pause();
            outputVideo.src = '';
            
            // Hide image container and zoom controls
            imageContainer.style.display = 'none';
            zoomControls.classList.remove('visible');
            
            // Set new video source and show container
            outputVideo.src = item.video_url;
            videoContainer.style.display = 'block';
            
            // Hide other elements
            document.getElementById('placeholder').style.display = 'none';
            document.getElementById('video-prompt-output').classList.remove('visible');
            document.getElementById('loading').classList.remove('visible');
            
            // Show controls
            document.getElementById('download-btn').classList.add('visible');
            document.getElementById('close-output').classList.add('visible');
            
            // Mark as seen
            if (newIds.has(item.id) || item.seen === false) {
                newIds.delete(item.id);
                const historyItemsItem = historyItems.find(h => h.id === item.id);
                if (historyItemsItem) historyItemsItem.seen = true;
                item.seen = true;
                fetch(`/api/history/${item.id}/seen`, { method: 'POST' })
                    .catch(e => console.warn('Failed to mark as seen:', e));
                renderHistory();
            }
            
            // Switch to OUTPUT tab on mobile
            if (isMobileView()) {
                switchMobilePanel('output');
            }
        }
        
        // Download video from URL
        async function downloadVideoFromUrl(videoUrl) {
            if (!videoUrl) return;
            
            try {
                const response = await fetch(videoUrl);
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'viewr_video_' + Date.now() + '.mp4';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            } catch (e) {
                // Fallback: open in new tab
                window.open(videoUrl, '_blank');
            }
        }
        
        // Recreate video prompt with same settings
        function recreateVideoPrompt(item) {
            // Switch to VIDEO mode
            currentInputMode = 'video';
            document.querySelectorAll('.input-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.inputMode === 'video');
            });
            
            // Restore video model
            currentVideoModel = item.video_model || 'kling-2.6-i2v';
            document.getElementById('video-model-select').value = currentVideoModel;
            updateEndFrameAvailability();
            
            // Restore audio toggle
            audioEnabled = item.audio_enabled !== false;
            document.querySelectorAll('.audio-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', 
                    (audioEnabled && btn.dataset.audio === 'on') || 
                    (!audioEnabled && btn.dataset.audio === 'off')
                );
            });
            updateAudioToggleVisibility();
            
            // Restore input prompt (for video mode)
            videoPrompt = item.input_prompt || '';
            document.getElementById('prompt').value = videoPrompt;
            
            // Restore start/end frame thumbnails if available
            if (item.start_frame_thumbnail) {
                startFrameImage = item.start_frame_thumbnail.startsWith('data:') 
                    ? item.start_frame_thumbnail 
                    : 'data:image/jpeg;base64,' + item.start_frame_thumbnail;
                updateVideoFramePreview('start', startFrameImage);
            } else {
                startFrameImage = null;
                updateVideoFramePreview('start', null);
            }
            
            if (item.end_frame_thumbnail) {
                endFrameImage = item.end_frame_thumbnail.startsWith('data:') 
                    ? item.end_frame_thumbnail 
                    : 'data:image/jpeg;base64,' + item.end_frame_thumbnail;
                updateVideoFramePreview('end', endFrameImage);
            } else {
                endFrameImage = null;
                updateVideoFramePreview('end', null);
            }
            
            updateInputModeUI();
            
            // Switch to INPUT tab on mobile so user can regenerate
            if (isMobileView()) {
                switchMobilePanel('inputs');
            }
        }
        
        // Download video prompt as text file
        function downloadVideoPrompt(item) {
            const text = item.generated_prompt || '';
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video-prompt-${item.video_model}-${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showEditCanvas(imageDataUrl) {
            const editCanvasContainer = document.getElementById('edit-canvas-container');
            const editBaseImage = document.getElementById('edit-base-image');
            const editMaskCanvas = document.getElementById('edit-mask-canvas');
            editBaseImage.onload = () => {
                editMaskCanvas.width = editBaseImage.naturalWidth;
                editMaskCanvas.height = editBaseImage.naturalHeight;
                maskCanvas = editMaskCanvas;
                maskCtx = maskCanvas.getContext('2d');
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                if (currentCanvasTool === 'brush') maskCanvas.classList.add('drawing');
                editCanvasContainer.classList.add('visible');
                undoStack = [];
                redoStack = [];
                saveCanvasState();
                updateUndoRedoButtons();
            };
            editBaseImage.src = imageDataUrl;
        }

        // MODEL SELECTOR
        function setupModelSelector() {
            document.getElementById('model-select').addEventListener('change', (e) => {
                currentModel = e.target.value;
                updateResolutionConstraints();
                updateQualityConstraints();
                updateEditModeAvailability();
                updateModelParamsVisibility();
            });
        }

        function updateModelOptions() {
            const modelSelect = document.getElementById('model-select');
            const qualitySection = document.getElementById('quality-section');
            modelSelect.innerHTML = '';
            if (currentMode === 'draft') {
                modelSelect.innerHTML = '<option value="nano-banana">Nano Banana</option><option value="gpt-image-1.5-low">GPT Image 1.5 (Low)</option>';
                qualitySection.style.display = 'none';
            } else {
                modelSelect.innerHTML = '<option value="nano-banana-pro">Nano Banana Pro</option><option value="gpt-image-1.5-medium">GPT Image 1.5 (Medium)</option><option value="gpt-image-1.5-high">GPT Image 1.5 (High)</option>';
                qualitySection.style.display = 'flex';
            }
            currentModel = modelSelect.value;
            updateResolutionConstraints();
            updateQualityConstraints();
            updateEditModeAvailability();
            updateModelParamsVisibility();
        }

        function updateResolutionConstraints() {
            const sel = document.getElementById('resolution');
            for (let i = 0; i < sel.options.length; i++) {
                sel.options[i].disabled = (currentModel === 'gpt-image-1.5-low' && sel.options[i].value !== '1:1' && sel.options[i].value !== 'auto');
            }
            if (currentModel === 'gpt-image-1.5-low' && sel.value !== '1:1' && sel.value !== 'auto') {
                sel.value = '1:1'; currentResolution = '1:1';
            }
        }

        function updateQualityConstraints() {
            const sel = document.getElementById('quality');
            for (let i = 0; i < sel.options.length; i++) {
                sel.options[i].disabled = (currentModel === 'gpt-image-1.5-low' && sel.options[i].value !== '1K');
            }
            if (currentModel === 'gpt-image-1.5-low') { sel.value = '1K'; currentQuality = '1K'; }
        }

        // Update model-specific parameter visibility based on current model and mode
        function updateModelParamsVisibility() {
            const gptParams = document.getElementById('gpt-image-params');
            const nanoBananaParams = document.getElementById('nano-banana-params');
            const nanoProParams = document.getElementById('nano-pro-params');
            const videoParams = document.getElementById('video-params');
            const motionControlParams = document.getElementById('motion-control-params');
            const avatarAudioSection = document.getElementById('avatar-audio-section');
            const gptFidelityRow = document.getElementById('gpt-fidelity-row');
            const cfgScaleRow = document.getElementById('cfg-scale-row');
            const durationSelect = document.getElementById('video-duration');
            
            // Hide all first
            gptParams.style.display = 'none';
            nanoBananaParams.style.display = 'none';
            nanoProParams.style.display = 'none';
            videoParams.style.display = 'none';
            motionControlParams.style.display = 'none';
            if (avatarAudioSection) avatarAudioSection.style.display = 'none';
            
            if (currentInputMode === 'video') {
                const capabilities = VIDEO_MODEL_CAPABILITIES[currentVideoModel] || {};
                
                // Avatar mode has different params - only show avatar params
                if (capabilities.avatar) {
                    if (avatarAudioSection) avatarAudioSection.style.display = 'flex';
                } else {
                    // Video mode - show video parameters
                    videoParams.style.display = 'flex';
                    
                    // Show/hide CFG scale row based on model capability
                    cfgScaleRow.style.display = capabilities.cfg_scale ? 'flex' : 'none';
                    
                    // Update duration options based on model (O1 models support 3-10s)
                    if (capabilities.extended_duration) {
                        durationSelect.innerHTML = `
                            <option value="3">3 seconds</option>
                            <option value="4">4 seconds</option>
                            <option value="5">5 seconds</option>
                            <option value="6">6 seconds</option>
                            <option value="7">7 seconds</option>
                            <option value="8">8 seconds</option>
                            <option value="9">9 seconds</option>
                            <option value="10">10 seconds</option>
                        `;
                    } else {
                        durationSelect.innerHTML = `
                            <option value="5">5 seconds</option>
                            <option value="10">10 seconds</option>
                        `;
                    }
                    // Reset to valid default if current value not in options
                    if (!Array.from(durationSelect.options).some(opt => opt.value === videoDuration)) {
                        videoDuration = '5';
                    }
                    durationSelect.value = videoDuration;
                    
                    // Show motion control rows if the model supports it
                    if (capabilities.motion_video) {
                        motionControlParams.style.display = 'flex';
                    }
                }
            } else {
                // Image mode - show model-specific params
                if (currentModel.startsWith('gpt-image-1.5')) {
                    gptParams.style.display = 'flex';
                    // Show input fidelity only in edit mode
                    gptFidelityRow.style.display = (currentInputMode === 'edit') ? 'flex' : 'none';
                } else if (currentModel === 'nano-banana') {
                    nanoBananaParams.style.display = 'flex';
                } else if (currentModel === 'nano-banana-pro') {
                    nanoProParams.style.display = 'flex';
                }
            }
        }

        // Disable Edit mode toggle for models that don't support mask editing
        // Only GPT Image 1.5 supports mask_image_url parameter for mask-based editing
        function updateEditModeAvailability() {
            const editBtn = document.querySelector('.input-mode-btn[data-input-mode="edit"]');
            const promptBtn = document.querySelector('.input-mode-btn[data-input-mode="prompt"]');
            
            // Only GPT Image 1.5 variants support mask image editing
            // Nano Banana and Nano Banana Pro do not support mask_image_url parameter
            const supportsEdit = currentModel.startsWith('gpt-image-1.5');
            
            if (!supportsEdit) {
                editBtn.disabled = true;
                editBtn.style.opacity = '0.4';
                editBtn.style.cursor = 'not-allowed';
                editBtn.title = 'Edit mode requires GPT Image 1.5 (only model with mask editing support)';
                
                // If currently in edit mode, switch to prompt mode
                if (currentInputMode === 'edit') {
                    currentInputMode = 'prompt';
                    editBtn.classList.remove('active');
                    promptBtn.classList.add('active');
                    updateInputModeUI();
                }
            } else {
                editBtn.disabled = false;
                editBtn.style.opacity = '1';
                editBtn.style.cursor = 'pointer';
                editBtn.title = '';
            }
        }

        // CANVAS TOOLS
        function setupCanvasTools() {
            const brushSlider = document.getElementById('brush-slider');
            const brushSizeValue = document.getElementById('brush-size-value');
            const brushTool = document.getElementById('brush-tool');
            const moveTool = document.getElementById('move-tool');
            const editMaskCanvas = document.getElementById('edit-mask-canvas');
            const editCanvasWrapper = document.getElementById('edit-canvas-wrapper');
            brushSlider.addEventListener('input', (e) => { 
                brushSize = parseInt(e.target.value); 
                brushSizeValue.textContent = brushSize; 
                showBrushPreview();
            });
            brushTool.addEventListener('click', () => { currentCanvasTool = 'brush'; brushTool.classList.add('active'); moveTool.classList.remove('active'); if (maskCanvas) { maskCanvas.classList.add('drawing'); maskCanvas.classList.remove('moving'); } });
            moveTool.addEventListener('click', () => { currentCanvasTool = 'move'; moveTool.classList.add('active'); brushTool.classList.remove('active'); if (maskCanvas) { maskCanvas.classList.remove('drawing'); maskCanvas.classList.add('moving'); } });

            // Mouse events for brush AND move tool on mask canvas
            // (mask canvas sits on top and intercepts all mouse events)
            editMaskCanvas.addEventListener('mousedown', (e) => {
                if (currentCanvasTool === 'brush') {
                    startDrawing(e);
                } else if (currentCanvasTool === 'move') {
                    startEditDrag(e);
                }
            });
            editMaskCanvas.addEventListener('mousemove', (e) => {
                if (currentCanvasTool === 'brush') {
                    draw(e);
                    updateBrushCursor(e);
                } else if (currentCanvasTool === 'move') {
                    editDrag(e);
                }
            });
            editMaskCanvas.addEventListener('mouseup', (e) => {
                stopDrawing();
                stopEditDrag();
            });
            editMaskCanvas.addEventListener('mouseleave', (e) => {
                stopDrawing();
                stopEditDrag();
                hideBrushCursor();
            });
            editMaskCanvas.addEventListener('mouseenter', (e) => {
                if (currentCanvasTool === 'brush') {
                    showBrushCursor();
                    updateBrushCursor(e);
                }
            });

            // Touch events for brush/move on edit canvas (mobile)
            // Handle both brush drawing AND move tool panning on the mask canvas
            // since it sits on top and intercepts all touch events
            editMaskCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2 && currentCanvasTool === 'move') {
                    // Pinch-to-zoom for edit canvas
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    editTouchStartDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    editTouchStartZoom = editCanvasZoom;
                } else if (e.touches.length === 1) {
                    if (currentCanvasTool === 'brush') {
                        e.preventDefault();
                        startDrawing(e.touches[0]);
                    } else if (currentCanvasTool === 'move') {
                        e.preventDefault();
                        startEditDrag(e.touches[0]);
                    }
                }
            }, { passive: false });

            editMaskCanvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && currentCanvasTool === 'move') {
                    // Pinch-to-zoom for edit canvas
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scale = currentDistance / editTouchStartDistance;
                    editCanvasZoom = Math.max(0.5, Math.min(5, editTouchStartZoom * scale));
                    updateEditCanvasTransform();
                } else if (e.touches.length === 1) {
                    if (currentCanvasTool === 'brush' && isDrawing) {
                        e.preventDefault();
                        draw(e.touches[0]);
                    } else if (currentCanvasTool === 'move' && isEditDragging) {
                        e.preventDefault();
                        editDrag(e.touches[0]);
                    }
                }
            }, { passive: false });

            editMaskCanvas.addEventListener('touchend', (e) => {
                stopDrawing();
                stopEditDrag();
            });

                        editMaskCanvas.addEventListener('touchcancel', (e) => {
                stopDrawing();
                stopEditDrag();
            });

            // Mouse wheel zoom for edit canvas
            editMaskCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY < 0 ? 0.1 : -0.1;
                editCanvasZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, editCanvasZoom + delta));
                updateEditCanvasTransform();
            }, { passive: false });

            // Setup undo/redo buttons (desktop and mobile)
            setupUndoRedo();
        }

        // Brush size preview
        function showBrushPreview() {
            const preview = document.getElementById('brush-preview');
            preview.style.width = brushSize + 'px';
            preview.style.height = brushSize + 'px';
            preview.classList.add('visible');
            
            if (brushPreviewTimeout) clearTimeout(brushPreviewTimeout);
            brushPreviewTimeout = setTimeout(() => {
                preview.classList.remove('visible');
            }, 500);
        }
        
        // Brush cursor functions
        function showBrushCursor() {
            const cursor = document.getElementById('brush-cursor');
            cursor.classList.add('visible');
            updateBrushCursorSize();
        }
        
        function hideBrushCursor() {
            const cursor = document.getElementById('brush-cursor');
            cursor.classList.remove('visible');
        }
        
        function updateBrushCursor(e) {
            const cursor = document.getElementById('brush-cursor');
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
            updateBrushCursorSize();
        }
        
        function updateBrushCursorSize() {
            const cursor = document.getElementById('brush-cursor');
            const scaledSize = brushSize * editCanvasZoom;
            cursor.style.width = scaledSize + 'px';
            cursor.style.height = scaledSize + 'px';
        }

        // Undo/Redo functionality
        function setupUndoRedo() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const mobileUndoBtn = document.getElementById('mobile-undo-btn');
            const mobileRedoBtn = document.getElementById('mobile-redo-btn');

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            mobileUndoBtn.addEventListener('click', undo);
            mobileRedoBtn.addEventListener('click', redo);
        }

        function saveCanvasState() {
            if (!maskCanvas) return;
            const state = maskCanvas.toDataURL();
            undoStack.push(state);
            redoStack = []; // Clear redo stack on new action
            updateUndoRedoButtons();
        }

        function undo() {
            // Need at least 2 states: initial + current to undo
            if (undoStack.length <= 1 || !maskCanvas || !maskCtx) return;
            
            // Pop current state and push to redo stack
            const currentState = undoStack.pop();
            redoStack.push(currentState);
            
            // Get previous state (don't pop, just peek)
            const previousState = undoStack[undoStack.length - 1];
            
            // Restore previous state
            const img = new Image();
            img.onload = () => {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                maskCtx.drawImage(img, 0, 0);
                updateUndoRedoButtons();
            };
            img.src = previousState;
        }

        function redo() {
            if (redoStack.length === 0 || !maskCanvas || !maskCtx) return;
            
            // Pop from redo stack and push to undo stack
            const nextState = redoStack.pop();
            undoStack.push(nextState);
            
            // Restore next state
            const img = new Image();
            img.onload = () => {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                maskCtx.drawImage(img, 0, 0);
                updateUndoRedoButtons();
            };
            img.src = nextState;
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const mobileUndoBtn = document.getElementById('mobile-undo-btn');
            const mobileRedoBtn = document.getElementById('mobile-redo-btn');
            
            // Can undo if we have more than just the initial state
            const canUndo = undoStack.length > 1;
            const canRedo = redoStack.length > 0;
            
            undoBtn.disabled = !canUndo;
            redoBtn.disabled = !canRedo;
            mobileUndoBtn.disabled = !canUndo;
            mobileRedoBtn.disabled = !canRedo;
        }

        let lastX = 0;
        let lastY = 0;
        function startDrawing(e) { 
            if (currentCanvasTool !== 'brush' || !maskCtx) return; 
            isDrawing = true; 
            const pos = getCanvasPosition(e); 
            lastX = pos.x;
            lastY = pos.y;
            drawBrush(pos.x, pos.y); 
        }
        function draw(e) { 
            if (!isDrawing || currentCanvasTool !== 'brush' || !maskCtx) return; 
            const pos = getCanvasPosition(e); 
            drawBrushStroke(lastX, lastY, pos.x, pos.y);
            lastX = pos.x;
            lastY = pos.y;
        }
        function stopDrawing() { 
            if (isDrawing && currentCanvasTool === 'brush') {
                saveCanvasState(); // Save state after completing a brush stroke
            }
            isDrawing = false; 
        }
        // Touch gesture state
        let touchStartDistance = 0;
        let touchStartZoom = 1;

        function handleTouchStart(e) { 
            if (e.touches.length === 2 && currentCanvasTool === 'move') {
                // Two-finger pinch for zoom
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                touchStartZoom = editCanvasZoom;
            } else if (e.touches.length === 1) {
                if (currentCanvasTool === 'brush') {
                    e.preventDefault();
                    startDrawing(e.touches[0]);
                } else if (currentCanvasTool === 'move') {
                    e.preventDefault();
                    startEditDrag(e.touches[0]);
                }
            }
        }

        function handleTouchMove(e) { 
            if (e.touches.length === 2 && currentCanvasTool === 'move') {
                // Two-finger pinch for zoom
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const scale = currentDistance / touchStartDistance;
                editCanvasZoom = Math.max(0.5, Math.min(5, touchStartZoom * scale));
                updateEditCanvasTransform();
            } else if (e.touches.length === 1) {
                if (currentCanvasTool === 'brush') {
                    e.preventDefault();
                    draw(e.touches[0]);
                } else if (currentCanvasTool === 'move') {
                    e.preventDefault();
                    editDrag(e.touches[0]);
                }
            }
        }
        function getCanvasPosition(e) { const canvas = document.getElementById('edit-mask-canvas'); const rect = canvas.getBoundingClientRect(); return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) }; }
        function drawBrush(x, y) { 
            if (!maskCtx) return; 
            maskCtx.fillStyle = 'rgba(255, 0, 0, 0.5)'; 
            maskCtx.beginPath(); 
            maskCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2); 
            maskCtx.fill(); 
        }
        function drawBrushStroke(x1, y1, x2, y2) {
            if (!maskCtx) return;
            maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            maskCtx.lineWidth = brushSize;
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
            maskCtx.beginPath();
            maskCtx.moveTo(x1, y1);
            maskCtx.lineTo(x2, y2);
            maskCtx.stroke();
        }
        function startEditDrag(e) { 
            if (currentCanvasTool !== 'move') return; 
            isEditDragging = true; 
            if (maskCanvas) maskCanvas.classList.add('dragging');
            editDragStartX = e.clientX; 
            editDragStartY = e.clientY; 
            editStartOffsetX = editCanvasOffsetX; 
            editStartOffsetY = editCanvasOffsetY; 
        }
        function editDrag(e) { 
            if (!isEditDragging) return; 
            editCanvasOffsetX = editStartOffsetX + (e.clientX - editDragStartX); 
            editCanvasOffsetY = editStartOffsetY + (e.clientY - editDragStartY); 
            updateEditCanvasTransform(); 
        }
        function stopEditDrag() { isEditDragging = false; if (maskCanvas) maskCanvas.classList.remove('dragging'); }
        function updateEditCanvasTransform() { 
            document.getElementById('edit-canvas-wrapper').style.transform = `translate(${editCanvasOffsetX}px, ${editCanvasOffsetY}px) scale(${editCanvasZoom})`;
            // Update zoom level display for edit mode
            document.getElementById('zoom-level').textContent = Math.round(editCanvasZoom * 100) + '%';
        }
        function getMaskDataUrl() { return maskCanvas ? maskCanvas.toDataURL('image/png') : null; }
        function clearMask() { if (maskCtx && maskCanvas) maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); }

        // Clear output view
        function clearOutput() {
            const outputImage = document.getElementById('output-image');
            const imageContainer = document.getElementById('image-container');
            const videoContainer = document.getElementById('video-container');
            const outputVideo = document.getElementById('output-video');
            const placeholder = document.getElementById('placeholder');
            const loading = document.getElementById('loading');
            const downloadBtn = document.getElementById('download-btn');
            const zoomControls = document.getElementById('zoom-controls');
            const closeBtn = document.getElementById('close-output');
            const wasViewingHistory = viewingHistoryId !== null;

            // Clear image
            outputImage.src = '';
            imageContainer.style.display = 'none';
            
            // Clear video
            if (outputVideo) {
                outputVideo.pause();
                outputVideo.src = '';
            }
            if (videoContainer) {
                videoContainer.style.display = 'none';
            }
            
            // Hide video prompt output
            document.getElementById('video-prompt-output').classList.remove('visible');
            
            downloadBtn.classList.remove('visible');
            viewingHistoryId = null;

            // Reset zoom
            zoomLevel = 1;
            offsetX = 0;
            offsetY = 0;

            // If generated from Edit Mode, return to Edit Mode with saved state
            if (generatedFromEditMode && savedEditImageForReturn) {
                const editCanvasContainer = document.getElementById('edit-canvas-container');
                const canvasTools = document.getElementById('canvas-tools');
                const mobileUndoRedo = document.getElementById('mobile-undo-redo');
                const undoRedoControls = document.getElementById('undo-redo-controls');
                
                // Restore edit canvas with saved image
                showEditCanvas(savedEditImageForReturn);
                
                // Restore mask if saved
                if (savedMaskDataForReturn && maskCanvas && maskCtx) {
                    const maskImg = new Image();
                    maskImg.onload = () => {
                        maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                        maskCtx.drawImage(maskImg, 0, 0, maskCanvas.width, maskCanvas.height);
                        undoStack = [];
                        redoStack = [];
                        saveCanvasState();
                        updateUndoRedoButtons();
                    };
                    maskImg.src = savedMaskDataForReturn;
                }
                
                editCanvasContainer.classList.add('visible');
                canvasTools.classList.add('visible');
                mobileUndoRedo.classList.add('visible');
                undoRedoControls.classList.add('visible');
                zoomControls.classList.add('visible');
                closeBtn.classList.add('visible');
                placeholder.style.display = 'none';
                loading.classList.remove('visible');
                document.getElementById('zoom-level').textContent = Math.round(editCanvasZoom * 100) + '%';
                
                // Clear the saved state
                generatedFromEditMode = false;
                savedEditImageForReturn = null;
                savedMaskDataForReturn = null;
                return;
            }
            
            // If in edit mode with an edit image, restore edit canvas view
            if (currentInputMode === 'edit' && editImage) {
                // If we were viewing a historyItems image, restore the edit canvas
                if (wasViewingHistory) {
                    const editCanvasContainer = document.getElementById('edit-canvas-container');
                    const canvasTools = document.getElementById('canvas-tools');
                    const mobileUndoRedo = document.getElementById('mobile-undo-redo');
                    const undoRedoControls = document.getElementById('undo-redo-controls');
                    editCanvasContainer.classList.add('visible');
                    canvasTools.classList.add('visible');
                    mobileUndoRedo.classList.add('visible');
                    undoRedoControls.classList.add('visible');
                    zoomControls.classList.add('visible');
                    closeBtn.classList.add('visible');
                    placeholder.style.display = 'none';
                    loading.classList.remove('visible');
                    // Update zoom display to edit canvas zoom
                    document.getElementById('zoom-level').textContent = Math.round(editCanvasZoom * 100) + '%';
                    return;
                }
                // Not viewing historyItems - clear the edit image
                clearImage('edit');
                const editCanvasContainer = document.getElementById('edit-canvas-container');
                const canvasTools = document.getElementById('canvas-tools');
                const mobileUndoRedo = document.getElementById('mobile-undo-redo');
                const undoRedoControls = document.getElementById('undo-redo-controls');
                editCanvasContainer.classList.remove('visible');
                canvasTools.classList.remove('visible');
                mobileUndoRedo.classList.remove('visible');
                undoRedoControls.classList.remove('visible');
                zoomControls.classList.remove('visible');
                closeBtn.classList.remove('visible');
                const editModePlaceholder = document.getElementById('edit-mode-placeholder');
                editModePlaceholder.classList.add('visible');
                placeholder.style.display = 'none';
                loading.classList.remove('visible');
                return;
            }
            
            // Not in edit mode with image - hide controls
            zoomControls.classList.remove('visible');
            closeBtn.classList.remove('visible');

            // If still generating, show loading spinner; otherwise show placeholder
            if (isGenerating) {
                loading.classList.add('visible');
                placeholder.style.display = 'none';
            } else {
                loading.classList.remove('visible');
                placeholder.style.display = 'block';
                placeholder.textContent = 'Generated image appears here';
            }
        }

        document.getElementById('close-output').addEventListener('click', clearOutput);

        // Sync state with MongoDB
        async function saveState() {
            // Update reset button visibility immediately (if function exists)
            if (typeof updateResetButtonVisibility === 'function') {
                updateResetButtonVisibility();
            }
            
            // Debounce saves
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    // Update the appropriate prompt state variable before saving
                    const currentPromptValue = document.getElementById('prompt').value;
                    if (currentInputMode === 'video') {
                        videoPrompt = currentPromptValue;
                    } else {
                        imagePrompt = currentPromptValue;
                    }
                    
                    await fetch('/api/state', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            // Don't save image data - clear on refresh
                            image_prompt: imagePrompt,
                            video_prompt: videoPrompt,
                            input_mode: currentInputMode,
                            mode: currentMode,
                            model: currentModel,
                            ref_attributes: selectedRefAttributes
                        })
                    });
                } catch (e) {
                    console.warn('Failed to save state to MongoDB:', e);
                }
            }, 1000);
        }

        async function loadState() {
            try {
                const response = await fetch('/api/state');
                const data = await response.json();

                if (data.success && data.state) {
                    const s = data.state;

                    // Don't restore images - they should be cleared on refresh
                    // Only restore non-image state

                    // Restore separate prompts
                    if (s.image_prompt !== undefined) {
                        imagePrompt = s.image_prompt;
                    } else if (s.prompt) {
                        // Legacy: migrate old single prompt to imagePrompt
                        imagePrompt = s.prompt;
                    }
                    if (s.video_prompt !== undefined) {
                        videoPrompt = s.video_prompt;
                    }
                    
                    // Restore input mode and set appropriate prompt in textarea
                    if (s.input_mode) {
                        currentInputMode = s.input_mode;
                        document.querySelectorAll('.input-mode-btn').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.inputMode === currentInputMode);
                        });
                    }
                    
                    // Set the correct prompt in the textarea based on current mode
                    if (currentInputMode === 'video') {
                        document.getElementById('prompt').value = videoPrompt;
                    } else {
                        document.getElementById('prompt').value = imagePrompt;
                    }

                    // Restore mode
                    if (s.mode) {
                        currentMode = s.mode;
                        document.querySelectorAll('.mode-btn').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.mode === currentMode);
                        });
                        
                        // Update model dropdown to match restored mode
                        updateModelOptions();

                        // Show/hide quality dropdown based on mode
                        const qualitySection = document.getElementById('quality-section');
                        if (currentMode === 'pro') {
                            qualitySection.style.display = 'flex';
                        } else {
                            qualitySection.style.display = 'none';
                        }
                    }
                    
                    // Restore reference attributes
                    if (s.ref_attributes && Array.isArray(s.ref_attributes)) {
                        selectedRefAttributes = s.ref_attributes;
                        document.querySelectorAll('.ref-attr-btn').forEach(btn => {
                            btn.classList.toggle('active', selectedRefAttributes.includes(btn.dataset.attr));
                        });
                    }
                }
            } catch (e) {
                console.warn('Failed to load state from MongoDB:', e);
            }
        }

        function showImageInBox(boxId, dataUrl) {
            const box = document.getElementById(boxId);
            box.classList.add('has-image');
            let img = box.querySelector('img');
            if (!img) {
                img = document.createElement('img');
                box.insertBefore(img, box.firstChild);
            }
            img.src = dataUrl;
        }

        // Mode toggle
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;

                // Update model options based on new mode
                updateModelOptions();

                saveState();
            });
        });

        // Save prompt on change
        document.getElementById('prompt').addEventListener('input', () => {
            saveState();
        });

        // Resolution change
        document.getElementById('resolution').addEventListener('change', (e) => {
            currentResolution = e.target.value;
            saveState();
        });

        // Quality change (Pro mode only)
        document.getElementById('quality').addEventListener('change', (e) => {
            currentQuality = e.target.value;
            saveState();
        });

        // Zoom controls
        function updateZoom() {
            const img = document.getElementById('output-image');
            const levelDisplay = document.getElementById('zoom-level');
            img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
            levelDisplay.textContent = Math.round(zoomLevel * 100) + '%';
        }

        document.getElementById('zoom-in').addEventListener('click', () => {
            // In edit mode with edit image, only allow zoom when move tool is selected
            if (currentInputMode === 'edit' && editImage && !viewingHistoryId) {
                if (currentCanvasTool !== 'move') return;
                editCanvasZoom = Math.min(ZOOM_MAX, editCanvasZoom + 0.1);
                updateEditCanvasTransform();
            } else if (zoomLevel < ZOOM_MAX) {
                zoomLevel = Math.min(ZOOM_MAX, zoomLevel + 0.1);
                updateZoom();
            }
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            // In edit mode with edit image, only allow zoom when move tool is selected
            if (currentInputMode === 'edit' && editImage && !viewingHistoryId) {
                if (currentCanvasTool !== 'move') return;
                editCanvasZoom = Math.max(ZOOM_MIN, editCanvasZoom - 0.1);
                updateEditCanvasTransform();
            } else if (zoomLevel > ZOOM_MIN) {
                zoomLevel = Math.max(ZOOM_MIN, zoomLevel - 0.1);
                updateZoom();
            }
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            // In edit mode with edit image, only allow zoom when move tool is selected
            if (currentInputMode === 'edit' && editImage && !viewingHistoryId) {
                if (currentCanvasTool !== 'move') return;
                editCanvasZoom = 1;
                editCanvasOffsetX = 0;
                editCanvasOffsetY = 0;
                updateEditCanvasTransform();
            } else {
                zoomLevel = 1;
                offsetX = 0;
                offsetY = 0;
                updateZoom();
            }
        });

        // Compare button - hold to show original, release to show generated
        const compareBtn = document.getElementById('compare-btn');
        const outputImage = document.getElementById('output-image');
        
        function showOriginalImage() {
            if (compareOriginalImage && !compareBtn.disabled) {
                outputImage.src = compareOriginalImage;
            }
        }
        
        function showGeneratedImage() {
            if (compareGeneratedImage && !compareBtn.disabled) {
                outputImage.src = compareGeneratedImage;
            }
        }
        
        // Mouse events for compare
        compareBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            showOriginalImage();
        });
        compareBtn.addEventListener('mouseup', showGeneratedImage);
        compareBtn.addEventListener('mouseleave', showGeneratedImage);
        
        // Touch events for compare (mobile)
        compareBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            showOriginalImage();
        });
        compareBtn.addEventListener('touchend', showGeneratedImage);
        compareBtn.addEventListener('touchcancel', showGeneratedImage);

        // Mouse wheel zoom on image (5% increments)
        document.getElementById('image-container').addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY < 0 ? ZOOM_STEP : -ZOOM_STEP;
            zoomLevel = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoomLevel + delta));
            updateZoom();
        });

        // Drag to pan (Mouse events)
        const imageContainer = document.getElementById('image-container');

        imageContainer.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only left mouse button
            isDragging = true;
            imageContainer.classList.add('dragging');
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            startOffsetX = offsetX;
            startOffsetY = offsetY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            // Free movement - no bounds restriction
            offsetX = startOffsetX + (e.clientX - dragStartX);
            offsetY = startOffsetY + (e.clientY - dragStartY);

            // Direct DOM update for smooth dragging (no transition)
            const img = document.getElementById('output-image');
            if (img) {
                img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                imageContainer.classList.remove('dragging');
            }
        });

        // Touch events for mobile drag-to-pan and pinch-to-zoom
        let outputPinchStartDistance = 0;
        let outputPinchStartZoom = 1;

        imageContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                // Two-finger pinch start
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                outputPinchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                outputPinchStartZoom = zoomLevel;
                isDragging = false;
            } else if (e.touches.length === 1) {
                isDragging = true;
                imageContainer.classList.add('dragging');
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                startOffsetX = offsetX;
                startOffsetY = offsetY;
            }
        }, { passive: false });

        imageContainer.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                // Two-finger pinch-to-zoom
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const scale = currentDistance / outputPinchStartDistance;
                zoomLevel = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, outputPinchStartZoom * scale));
                updateZoom();
            } else if (isDragging && e.touches.length === 1) {
                // Single-finger pan
                e.preventDefault();
                offsetX = startOffsetX + (e.touches[0].clientX - dragStartX);
                offsetY = startOffsetY + (e.touches[0].clientY - dragStartY);

                const img = document.getElementById('output-image');
                if (img) {
                    img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
                }
            }
        }, { passive: false });

        imageContainer.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                imageContainer.classList.remove('dragging');
            }
        });

        imageContainer.addEventListener('touchcancel', () => {
            if (isDragging) {
                isDragging = false;
                imageContainer.classList.remove('dragging');
            }
        });

        // Multi-reference image handling
        let refIdCounter = 0;

        function generateRefId() {
            return 'ref_' + (++refIdCounter) + '_' + Date.now();
        }

        function renderReferenceGrid() {
            const grid = document.getElementById('reference-grid');
            const addBox = document.getElementById('add-reference-box');
            const clearAllBtn = document.getElementById('clear-all-refs');
            const refAttributes = document.getElementById('ref-attributes');
            
            // Remove all reference items (keep the add box)
            grid.querySelectorAll('.reference-item').forEach(el => el.remove());
            
            // Add reference items before the add box
            referenceImages.forEach(ref => {
                const item = document.createElement('div');
                item.className = 'reference-item';
                item.dataset.refId = ref.id;
                item.innerHTML = `
                    <img src="${ref.dataUrl}" alt="Reference">
                    <button class="remove-btn">&times;</button>
                `;
                
                // Click to view in lightbox
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('remove-btn')) {
                        showLightbox(ref.dataUrl);
                    }
                });
                
                // Remove button
                item.querySelector('.remove-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeReference(ref.id);
                });
                
                grid.insertBefore(item, addBox);
            });
            
            // Show/hide clear all button and toggle grid border style
            clearAllBtn.style.display = referenceImages.length > 0 ? 'block' : 'none';
            grid.classList.toggle('has-images', referenceImages.length > 0);
            
            // Show/hide character attributes based on whether there are reference images
            if (refAttributes) {
                refAttributes.style.display = referenceImages.length > 0 ? 'block' : 'none';
            }
            
            // Update combined traits display
            updateCombinedTraits();
        }

        function updateCombinedTraits() {
            const allTraits = referenceImages
                .filter(ref => ref.traits)
                .map((ref, i) => `[Ref ${i + 1}] ${ref.traits}`)
                .join('\n\n');
            
            detectedTraits = allTraits;
            
            const traitsDisplay = document.getElementById('traits-display');
            if (allTraits) {
                document.getElementById('traits-text').textContent = allTraits;
                traitsDisplay.classList.add('visible');
                traitsDisplay.style.display = 'block';
            } else {
                traitsDisplay.classList.remove('visible');
                traitsDisplay.style.display = 'none';
            }
        }

        async function addReference(dataUrl) {
            const refId = generateRefId();
            const newRef = { id: refId, dataUrl: dataUrl, traits: '' };
            referenceImages.push(newRef);
            renderReferenceGrid();
            saveState();
            
            // Analyze the new reference
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: dataUrl, type: 'reference' })
                });

                const data = await response.json();
                if (data.success && data.traits) {
                    // Update the reference with traits
                    const ref = referenceImages.find(r => r.id === refId);
                    if (ref) {
                        ref.traits = data.traits;
                        updateCombinedTraits();
                        saveState();
                    }
                }
            } catch (e) {
                console.error('Analysis failed:', e);
            }
        }

        function removeReference(refId) {
            referenceImages = referenceImages.filter(r => r.id !== refId);
            renderReferenceGrid();
            saveState();
        }

        function clearAllReferences() {
            referenceImages = [];
            detectedTraits = '';
            document.getElementById('traits-display').classList.remove('visible');
            document.getElementById('traits-display').style.display = 'none';
            renderReferenceGrid();
            saveState();
        }

        // Reset All for Image Mode (Prompt/Edit modes)
        function resetAllImage() {
            // Clear character references
            clearAllReferences();
            
            // Clear edit image
            clearImage('edit');
            
            // Clear prompt input
            document.getElementById('prompt').value = '';
            imagePrompt = '';
            originalPromptBeforeEnhance = null;
            document.getElementById('revert-prompt-btn').classList.remove('visible');
            
            // Reset GPT Image 1.5 settings to defaults
            document.getElementById('gpt-background').value = 'auto';
            document.getElementById('gpt-output-format').value = 'png';
            document.getElementById('gpt-input-fidelity').value = 'auto';
            gptBackground = 'auto';
            gptOutputFormat = 'png';
            gptInputFidelity = 'auto';
            
            // Reset Nano Banana settings to defaults
            document.getElementById('nano-output-format').value = 'png';
            nanoOutputFormat = 'png';
            
            // Reset Nano Banana Pro settings to defaults
            document.getElementById('nano-pro-output-format').value = 'png';
            document.getElementById('nano-pro-seed').value = '';
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                if (btn.id === 'web-search-on') btn.classList.add('active');
                else if (btn.id === 'web-search-off') btn.classList.remove('active');
            });
            nanoProOutputFormat = 'png';
            nanoProSeed = null;
            nanoProWebSearch = true;
            
            // Reset resolution to default (auto)
            document.getElementById('resolution').value = 'auto';
            currentResolution = 'auto';
            
            // Reset quality to default (4K) if in pro mode
            document.getElementById('quality').value = '4K';
            currentQuality = '4K';
            
            // Reset reference attributes to defaults (face and hair active)
            document.querySelectorAll('.ref-attr-btn').forEach(btn => {
                const attr = btn.dataset.attr;
                if (attr === 'face' || attr === 'hair') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            saveState();
            updateResetButtonVisibility();
        }

        // Reset All for Video Mode
        function resetAllVideo() {
            // Clear video character references
            clearAllVideoCharReferences();
            
            // Clear start frame and end frame
            clearVideoFrame('start');
            clearVideoFrame('end');
            
            // Clear prompt input
            document.getElementById('prompt').value = '';
            videoPrompt = '';
            
            // Reset audio toggle to default (on)
            audioEnabled = true;
            document.querySelectorAll('.audio-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.audio === 'on');
            });
            
            // Reset video settings to defaults
            document.getElementById('video-duration').value = '5';
            document.getElementById('video-negative-prompt').value = 'blur, distort, and low quality';
            document.getElementById('video-cfg-scale').value = '0.5';
            document.getElementById('cfg-scale-value').textContent = '0.5';
            videoDuration = '5';
            videoNegativePrompt = 'blur, distort, and low quality';
            videoCfgScale = 0.5;
            
            // Reset resolution to default (auto)
            document.getElementById('resolution').value = 'auto';
            currentResolution = 'auto';
            
            // Reset video character attributes to defaults
            document.querySelectorAll('#video-char-attributes .ref-attr-btn').forEach(btn => {
                const attr = btn.dataset.attr;
                if (attr === 'face' || attr === 'hair') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            saveState();
            updateResetButtonVisibility();
        }

        // Update Reset All button visibility based on whether there's content to reset
        function updateResetButtonVisibility() {
            const resetImageBtn = document.getElementById('reset-all-image');
            const resetVideoBtn = document.getElementById('reset-all-video');
            
            // Check if there's anything to reset in image mode
            const hasImageContent = referenceImages.length > 0 || 
                editImage || 
                (currentInputMode !== 'video' && document.getElementById('prompt').value.trim()) ||
                document.getElementById('resolution').value !== 'auto' ||
                document.getElementById('quality').value !== '4K' ||
                document.getElementById('gpt-background').value !== 'auto' ||
                document.getElementById('gpt-output-format').value !== 'png' ||
                document.getElementById('nano-output-format').value !== 'png' ||
                document.getElementById('nano-pro-output-format').value !== 'png' ||
                document.getElementById('nano-pro-seed').value;
            
            resetImageBtn.style.display = hasImageContent ? 'block' : 'none';
            
            // Check if there's anything to reset in video mode
            const hasVideoContent = videoCharReferences.length > 0 ||
                startFrameImage ||
                endFrameImage ||
                (currentInputMode === 'video' && document.getElementById('prompt').value.trim()) ||
                document.getElementById('video-duration').value !== '5' ||
                document.getElementById('video-negative-prompt').value !== 'blur, distort, and low quality' ||
                document.getElementById('video-cfg-scale').value !== '0.5' ||
                !audioEnabled;
            
            resetVideoBtn.style.display = hasVideoContent ? 'block' : 'none';
        }

        // Setup multi-reference upload
        function setupMultiReferenceUpload() {
            const input = document.getElementById('reference-input');
            const addBox = document.getElementById('add-reference-box');
            const clearAllBtn = document.getElementById('clear-all-refs');

            const handleFiles = (files) => {
                Array.from(files).forEach(file => {
                    if (!file || !file.type.startsWith('image/')) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        await addReference(event.target.result);
                    };
                    reader.readAsDataURL(file);
                });
            };

            // Click to add
            addBox.addEventListener('click', async () => {
                if ('showOpenFilePicker' in window) {
                    try {
                        const handles = await window.showOpenFilePicker({
                            id: 'reference',
                            multiple: true,
                            types: [{
                                description: 'Images',
                                accept: { 'image/*': ['.png', '.gif', '.jpeg', '.jpg', '.webp'] }
                            }]
                        });
                        for (const handle of handles) {
                            const file = await handle.getFile();
                            handleFiles([file]);
                        }
                    } catch (err) {
                        // User cancelled
                    }
                } else {
                    input.click();
                }
            });

            input.addEventListener('change', (e) => {
                handleFiles(e.target.files);
                input.value = '';
            });

            // Drag and Drop on add box
            addBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.add('dragover');
            });

            addBox.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
            });

            addBox.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                addBox.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });

            // Clear all button
            clearAllBtn.addEventListener('click', clearAllReferences);
        }

        setupMultiReferenceUpload();

        // Edit image upload handling (single image)
        function setupEditUpload(inputId, boxId) {
            const input = document.getElementById(inputId);
            const box = document.getElementById(boxId);

            const handleFile = (file) => {
                if (!file || !file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    const dataUrl = event.target.result;
                    showImageInBox(boxId, dataUrl);
                    editImage = dataUrl;
                    analyzeEditImage(dataUrl);
                    saveState();
                    // Update UI if in edit mode
                    if (currentInputMode === 'edit') {
                        updateInputModeUI();
                    }
                };
                reader.readAsDataURL(file);
            };

            box.addEventListener('click', async (e) => {
                if (e.target.closest('.clear-btn')) return;

                if (editImage && box.classList.contains('has-image')) {
                    showLightbox(editImage);
                    return;
                }

                if ('showOpenFilePicker' in window) {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            id: 'edit',
                            types: [{
                                description: 'Images',
                                accept: { 'image/*': ['.png', '.gif', '.jpeg', '.jpg', '.webp'] }
                            }]
                        });
                        const file = await handle.getFile();
                        handleFile(file);
                    } catch (err) {
                        // User cancelled
                    }
                } else {
                    input.click();
                }
            });

            input.addEventListener('change', (e) => {
                handleFile(e.target.files[0]);
            });

            box.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                box.classList.add('dragover');
            });

            box.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                box.classList.remove('dragover');
            });

            box.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                box.classList.remove('dragover');
                handleFile(e.dataTransfer.files[0]);
            });
        }

        setupEditUpload('edit-input', 'edit-box');

        // Reference attribute toggle buttons (prompt/edit mode only)
        document.querySelectorAll('#ref-attributes .ref-attr-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const attr = btn.dataset.attr;
                btn.classList.toggle('active');
                
                if (btn.classList.contains('active')) {
                    if (!selectedRefAttributes.includes(attr)) {
                        selectedRefAttributes.push(attr);
                    }
                } else {
                    selectedRefAttributes = selectedRefAttributes.filter(a => a !== attr);
                }
                
                saveState();
            });
        });

        // Clear image (for edit only now)
        function clearImage(type) {
            if (type === 'reference') {
                clearAllReferences();
                return;
            }
            
            const boxId = type + '-box';
            const inputId = type + '-input';
            const box = document.getElementById(boxId);
            const input = document.getElementById(inputId);

            box.classList.remove('has-image');
            const img = box.querySelector('img');
            if (img) img.remove();
            input.value = '';

            editImage = null;
            editTraits = '';
            document.getElementById('edit-traits-display').classList.remove('visible');
            document.getElementById('edit-traits-display').style.display = 'none';
            
            // Also clear the edit canvas in output area
            const editCanvasContainer = document.getElementById('edit-canvas-container');
            const canvasTools = document.getElementById('canvas-tools');
            const mobileUndoRedo = document.getElementById('mobile-undo-redo');
            const undoRedoControls = document.getElementById('undo-redo-controls');
            const zoomControls = document.getElementById('zoom-controls');
            const closeBtn = document.getElementById('close-output');
            const editModePlaceholder = document.getElementById('edit-mode-placeholder');
            
            editCanvasContainer.classList.remove('visible');
            canvasTools.classList.remove('visible');
            mobileUndoRedo.classList.remove('visible');
            undoRedoControls.classList.remove('visible');
            zoomControls.classList.remove('visible');
            closeBtn.classList.remove('visible');
            
            // Show edit mode placeholder
            if (currentInputMode === 'edit') {
                editModePlaceholder.classList.add('visible');
            }
            
            // Clear mask canvas
            clearMask();
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            
            saveState();
        }

        // Analyze reference image (now called per-image)
        async function analyzeReference(dataUrl) {
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: dataUrl, type: 'reference' })
                });

                const data = await response.json();
                return data.success ? data.traits : '';
            } catch (e) {
                console.error('Analysis failed:', e);
                return '';
            }
        }

        // Analyze edit image for clothing, accessories, environment
        async function analyzeEditImage(dataUrl) {
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: dataUrl, type: 'edit' })
                });

                const data = await response.json();
                if (data.success && data.traits) {
                    editTraits = data.traits;
                    document.getElementById('edit-traits-text').textContent = data.traits;
                    document.getElementById('edit-traits-display').classList.add('visible');
                    document.getElementById('edit-traits-display').style.display = 'block';
                    saveState();
                }
            } catch (e) {
                console.error('Edit image analysis failed:', e);
            }
        }

        // Generate
        document.getElementById('generate-btn').addEventListener('click', async () => {
            const prompt = document.getElementById('prompt').value.trim();
            
            // Handle VIDEO MODE separately - directly generate video using the prompt
            if (currentInputMode === 'video') {
                await generateVideoDirectly();
                return;
            }

            if (referenceImages.length === 0 && !prompt) {
                showError('Add a reference image or enter a prompt.');
                return;
            }

            const btn = document.getElementById('generate-btn');
            const loading = document.getElementById('loading');
            const placeholder = document.getElementById('placeholder');
            const outputImage = document.getElementById('output-image');
            const downloadBtn = document.getElementById('download-btn');
            const error = document.getElementById('error');

            const imageContainer = document.getElementById('image-container');
            const zoomControls = document.getElementById('zoom-controls');
            const closeBtn = document.getElementById('close-output');
            const resolution = document.getElementById('resolution').value;

            // Set generating state
            isGenerating = true;
            btn.disabled = true;
            btn.textContent = 'GENERATING...';
            error.classList.remove('visible');

            // Switch to OUTPUT tab on mobile when generating
            if (isMobileView()) {
                switchMobilePanel('output');
            }

            // Only hide current view if NOT viewing a historyItems item
            if (!viewingHistoryId) {
                loading.classList.add('visible');
                placeholder.style.display = 'none';
                imageContainer.style.display = 'none';
                zoomControls.classList.remove('visible');
                downloadBtn.classList.remove('visible');
                closeBtn.classList.remove('visible');
            }

            try {
                const quality = document.getElementById('quality').value;
                // Build model-specific params
                const modelParams = {};
                if (currentModel.startsWith('gpt-image-1.5')) {
                    modelParams.background = gptBackground;
                    modelParams.output_format = gptOutputFormat;
                    if (currentInputMode === 'edit') {
                        modelParams.input_fidelity = gptInputFidelity;
                    }
                } else if (currentModel === 'nano-banana') {
                    modelParams.output_format = nanoOutputFormat;
                } else if (currentModel === 'nano-banana-pro') {
                    modelParams.output_format = nanoProOutputFormat;
                    modelParams.enable_web_search = nanoProWebSearch;
                    // Auto-generate seed if not set, then display and save it for exact recreates
                    const seedInput = document.getElementById('nano-pro-seed');
                    if (!nanoProSeed) {
                        // Generate positive integer (1 to 2147483647) for reproducibility
                        nanoProSeed = Math.floor(Math.random() * 2147483647) + 1;
                        seedInput.value = nanoProSeed;
                        seedInput.classList.add('has-value');
                    }
                    modelParams.seed = nanoProSeed;
                }
                
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        reference_images: referenceImages.map(r => r.dataUrl),
                        edit_image: editImage,
                        prompt: prompt,
                        traits: detectedTraits,
                        ref_attributes: selectedRefAttributes,
                        edit_traits: editTraits,
                        mode: currentMode,
                        model: currentModel,
                        resolution: resolution,
                        quality: currentMode === 'pro' ? quality : '',
                        input_mode: currentInputMode,
                        mask_image: (currentInputMode === 'edit' && maskCanvas) ? getMaskDataUrl() : null,
                        model_params: modelParams
                    })
                });

                const data = await response.json();
                console.log('[VIEWR] API Response:', data);

                if (data.success && data.image) {
                    // Capture old historyItems IDs before refresh
                    const oldHistoryIds = new Set(historyItems.map(item => item.id));
                    console.log('[VIEWR] Old historyItems count:', oldHistoryIds.size);

                    // Refresh historyItems to get the new item
                    await refreshHistory();
                    console.log('[VIEWR] New historyItems count:', historyItems.length);

                    // Find new IDs and mark them
                    historyItems.forEach(item => {
                        if (!oldHistoryIds.has(item.id)) {
                            newIds.add(item.id);
                            console.log('[VIEWR] New item added to historyItems:', item.id);
                        }
                    });

                    // Re-render to show NEW badges
                    renderHistory();

                    // Also refresh saved to update save button states
                    await refreshSaved();

                    // Only auto-show new image if NOT viewing a historyItems item
                    if (!viewingHistoryId) {
                        // If generated from Edit Mode, save state for return
                        if (currentInputMode === 'edit' && editImage) {
                            generatedFromEditMode = true;
                            savedEditImageForReturn = editImage;
                            savedMaskDataForReturn = getMaskDataUrl();
                            
                            // Store images for compare button
                            compareOriginalImage = editImage;
                            compareGeneratedImage = 'data:image/png;base64,' + data.image;
                            document.getElementById('compare-btn').disabled = false;
                            
                            // Hide edit canvas and show generated image
                            const editCanvasContainer = document.getElementById('edit-canvas-container');
                            const canvasTools = document.getElementById('canvas-tools');
                            const mobileUndoRedo = document.getElementById('mobile-undo-redo');
                            const undoRedoControls = document.getElementById('undo-redo-controls');
                            editCanvasContainer.classList.remove('visible');
                            canvasTools.classList.remove('visible');
                            mobileUndoRedo.classList.remove('visible');
                            undoRedoControls.classList.remove('visible');
                        } else {
                            generatedFromEditMode = false;
                            savedEditImageForReturn = null;
                            savedMaskDataForReturn = null;
                            
                            // Disable compare button for non-edit generations
                            compareOriginalImage = null;
                            compareGeneratedImage = null;
                            document.getElementById('compare-btn').disabled = true;
                        }
                        
                        const imgSrc = 'data:image/png;base64,' + data.image;
                        outputImage.src = imgSrc;
                        imageContainer.style.display = 'flex';
                        zoomControls.classList.add('visible');
                        downloadBtn.classList.add('visible');
                        closeBtn.classList.add('visible');
                        placeholder.style.display = 'none';

                        // Reset zoom and offsets
                        zoomLevel = 1;
                        offsetX = 0;
                        offsetY = 0;
                        updateZoom();

                        // Auto-switch to OUTPUT tab on mobile
                        if (isMobileView()) {
                            switchMobilePanel('output');
                        }
                    }
                } else {
                    console.error('[VIEWR] Generation failed:', data.error);
                    showError(data.error || 'Generation failed.');
                    if (!viewingHistoryId) {
                        placeholder.style.display = 'block';
                        placeholder.textContent = data.error || 'Generation failed';
                    }
                }
            } catch (e) {
                showError('Request failed. Check your connection.');
            } finally {
                isGenerating = false;
                btn.disabled = false;
                btn.textContent = 'GENERATE';
                loading.classList.remove('visible');
            }
        });

        // History functions
        async function refreshHistory() {
            console.log('[VIEWR] refreshHistory() called');
            try {
                const response = await fetch('/api/history');
                const data = await response.json();
                console.log('[VIEWR] /api/history full response:', JSON.stringify(data).substring(0, 500));
                console.log('[VIEWR] data.history exists:', !!data.history);
                console.log('[VIEWR] data.history type:', typeof data.history);
                console.log('[VIEWR] History items count:', data.history ? data.history.length : 0);

                if (data.success) {
                    historyItems = data.history || [];
                    console.log('[VIEWR] Calling renderHistory() with', historyItems.length, 'items');
                    renderHistory();
                } else {
                    console.error('[VIEWR] History fetch failed:', data.error);
                }
            } catch (e) {
                console.error('[VIEWR] Failed to fetch history:', e);
            }
        }

        function renderHistory() {
            console.log('[VIEWR] renderHistory() called, historyItems length:', historyItems.length);
            const list = document.getElementById('history-list');
            const empty = document.getElementById('history-empty');
            
            console.log('[VIEWR] history-list element:', list);
            console.log('[VIEWR] history-empty element:', empty);
            console.log('[VIEWR] currentTab:', currentTab);

            // Ensure historyItems list is visible if on historyItems tab
            if (currentTab === 'history') {
                list.style.display = 'flex';
            }

            // Always clear existing items first
            list.querySelectorAll('.history-item').forEach(el => el.remove());

            if (historyItems.length === 0) {
                empty.style.display = 'block';
                console.log('[VIEWR] History is empty, showing empty message');
                return;
            }

            empty.style.display = 'none';

            // Filter out video_prompt items - they are no longer displayed in history
            const filteredItems = historyItems.filter(item => item.type !== 'video_prompt');
            
            if (filteredItems.length === 0) {
                empty.style.display = 'block';
                console.log('[VIEWR] No displayable history items after filtering');
                return;
            }

            filteredItems.forEach((item, index) => {
                try {
                    const div = createItemCard(item, 'history');
                    list.appendChild(div);
                    console.log('[VIEWR] Added historyItems item', index, ':', item.type, item.id);
                } catch (e) {
                    console.error('[VIEWR] Failed to create item card for item', index, ':', e);
                }
            });

            console.log('[VIEWR] Rendered', filteredItems.length, 'historyItems items (filtered from', historyItems.length, ')');
        }

        function createItemCard(item, type) {
            // Check if this is a generated video item
            const isVideo = item.type === 'video';
            
            // Check if saved by comparing gridfs_id (preferred), video_url for videos, or image thumbnail
            const isSaved = type === 'saved' || saved.some(s =>
                (s.gridfs_id && item.gridfs_id && s.gridfs_id === item.gridfs_id) ||
                (s.video_url && item.video_url && s.video_url === item.video_url) ||
                (s.image === item.image) ||
                (s.id === item.id)
            );
            // Check if new: either from memory (just generated) or from database (not seen yet)
            const isNew = type === 'history' && (newIds.has(item.id) || item.seen === false);
            const div = document.createElement('div');
            
            if (isVideo) {
                // Generated video history item
                div.className = 'history-item video-item';
                const modelLabel = getVideoModelLabel(item.video_model);
                // Prefer start frame thumbnail (original quality) over video thumbnail (compressed first frame)
                const thumbnail = item.start_frame_thumbnail || item.video_thumbnail;
                div.innerHTML = `
                    ${isNew ? '<div class="new-badge">NEW</div>' : ''}
                    <div class="video-preview">
                        <div class="video-play-icon"></div>
                        ${thumbnail ? `<img src="data:image/jpeg;base64,${thumbnail}" alt="Video thumbnail">` : '<div class="video-placeholder">VIDEO</div>'}
                    </div>
                    <div class="history-item-info">
                        <div class="history-item-text" title="${escapeHtml(item.prompt || '(no prompt)')}">
                            <div class="history-item-prompt">${escapeHtml(item.prompt || '(no prompt)')}</div>
                            <div class="history-item-time">${item.time}  ${modelLabel}</div>
                        </div>
                        <div class="history-item-actions">
                            <button class="history-action-btn" data-action="recreate" title="Recreate">${ICONS.recreate}</button>
                            <button class="history-action-btn" data-action="download" title="Download">${ICONS.download}</button>
                            <button class="history-action-btn" data-action="save" title="${isSaved ? 'Saved' : 'Save'}">${isSaved ? ICONS.saved : ICONS.save}</button>
                            <button class="history-action-btn" data-action="delete" title="Delete">${ICONS.delete}</button>
                        </div>
                    </div>
                `;
                
                // Click on preview to load video in output
                div.querySelector('.video-preview').onclick = () => loadVideoFromHistory(item);
                div.querySelector('.history-item-text').onclick = () => loadVideoFromHistory(item);
                
                div.querySelector('[data-action="recreate"]').onclick = (e) => {
                    e.stopPropagation();
                    recreateVideoFromItem(item);
                };
                
                div.querySelector('[data-action="download"]').onclick = (e) => {
                    e.stopPropagation();
                    downloadVideoFromUrl(item.video_url);
                };
                
                div.querySelector('[data-action="save"]').onclick = (e) => {
                    e.stopPropagation();
                    saveToSaved(item);
                };
                
                div.querySelector('[data-action="delete"]').onclick = (e) => {
                    e.stopPropagation();
                    deleteItem(item.id, type);
                };
            } else {
                // Image historyItems item
                div.className = 'history-item';
                div.innerHTML = `
                    ${isNew ? '<div class="new-badge">NEW</div>' : ''}
                    <img src="data:image/png;base64,${item.image}" alt="Generated">
                    <div class="history-item-info">
                        <div class="history-item-text" title="${escapeHtml(item.prompt || '(no prompt)')}">
                            <div class="history-item-prompt">${escapeHtml(item.prompt || '(no prompt)')}</div>
                            <div class="history-item-time">${item.time}  ${(item.mode || 'draft').toUpperCase()}</div>
                        </div>
                        <div class="history-item-actions">
                            <button class="history-action-btn" data-action="recreate" title="Recreate">${ICONS.recreate}</button>
                            <button class="history-action-btn" data-action="download" title="Download">${ICONS.download}</button>
                            <button class="history-action-btn" data-action="save" title="${isSaved ? 'Saved' : 'Save'}">${isSaved ? ICONS.saved : ICONS.save}</button>
                            <button class="history-action-btn" data-action="delete" title="Delete">${ICONS.delete}</button>
                        </div>
                    </div>
                `;

                // Click on image to load in main view
                div.querySelector('img').onclick = () => loadFromHistory(item);
                div.querySelector('.history-item-text').onclick = () => loadFromHistory(item);

                // Action buttons
                div.querySelector('[data-action="recreate"]').onclick = (e) => {
                    e.stopPropagation();
                    recreateFromItem(item);
                };

                div.querySelector('[data-action="download"]').onclick = (e) => {
                    e.stopPropagation();
                    downloadImage(item);
                };

                div.querySelector('[data-action="save"]').onclick = (e) => {
                    e.stopPropagation();
                    saveToSaved(item);
                };

                div.querySelector('[data-action="delete"]').onclick = (e) => {
                    e.stopPropagation();
                    deleteItem(item.id, type);
                };
            }

            return div;
        }

        async function recreateFromItem(item) {
            // Fetch full-quality reference images from GridFS if available
            const refGridfsIds = item.reference_gridfs_ids || [];
            const refThumbnails = item.reference_thumbnails || [];
            const legacyRef = item.reference_image;
            
            if (refGridfsIds.length > 0) {
                // Fetch full-quality references from GridFS
                referenceImages = [];
                for (let i = 0; i < refGridfsIds.length; i++) {
                    try {
                        const response = await fetch(`/api/image/${refGridfsIds[i]}`);
                        const data = await response.json();
                        if (data.success && data.image) {
                            referenceImages.push({
                                id: 'ref_recreate_' + i + '_' + Date.now(),
                                dataUrl: 'data:image/png;base64,' + data.image,
                                traits: ''
                            });
                        }
                    } catch (e) {
                        console.error('[VIEWR] Failed to fetch reference from GridFS:', e);
                        // Fallback to thumbnail
                        if (refThumbnails[i]) {
                            const dataUrl = refThumbnails[i].startsWith('data:') ? refThumbnails[i] : 'data:image/jpeg;base64,' + refThumbnails[i];
                            referenceImages.push({
                                id: 'ref_recreate_' + i + '_' + Date.now(),
                                dataUrl: dataUrl,
                                traits: ''
                            });
                        }
                    }
                }
                renderReferenceGrid();
            } else if (refThumbnails.length > 0) {
                // Fallback: use thumbnails (legacy items)
                referenceImages = refThumbnails.map((thumb, i) => {
                    const dataUrl = thumb.startsWith('data:') ? thumb : 'data:image/jpeg;base64,' + thumb;
                    return {
                        id: 'ref_recreate_' + i + '_' + Date.now(),
                        dataUrl: dataUrl,
                        traits: ''
                    };
                });
                renderReferenceGrid();
            } else if (legacyRef) {
                // Legacy single reference
                const refDataUrl = legacyRef.startsWith('data:') ? legacyRef : 'data:image/jpeg;base64,' + legacyRef;
                referenceImages = [{
                    id: 'ref_legacy_' + Date.now(),
                    dataUrl: refDataUrl,
                    traits: item.traits || ''
                }];
                renderReferenceGrid();
            } else {
                clearAllReferences();
            }

            // Fetch full-quality edit image from GridFS if available
            let editDataUrl = null;
            if (item.edit_gridfs_id) {
                try {
                    const response = await fetch(`/api/image/${item.edit_gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        editDataUrl = 'data:image/png;base64,' + data.image;
                        console.log('[VIEWR] Loaded full-quality edit image from GridFS');
                    }
                } catch (e) {
                    console.error('[VIEWR] Failed to fetch edit image from GridFS:', e);
                }
            }
            // Fallback to thumbnail if GridFS fetch failed
            if (!editDataUrl && item.edit_image) {
                editDataUrl = item.edit_image.startsWith('data:')
                    ? item.edit_image
                    : 'data:image/jpeg;base64,' + item.edit_image;
            }
            
            if (editDataUrl) {
                editImage = editDataUrl;
                showImageInBox('edit-box', editDataUrl);
            } else {
                clearImage('edit');
            }

            // Restore traits
            if (item.traits) {
                detectedTraits = item.traits;
                document.getElementById('traits-text').textContent = item.traits;
                document.getElementById('traits-display').classList.add('visible');
                document.getElementById('traits-display').style.display = 'block';
            } else {
                detectedTraits = '';
                document.getElementById('traits-display').classList.remove('visible');
                document.getElementById('traits-display').style.display = 'none';
            }

            // Restore edit traits
            if (item.edit_traits) {
                editTraits = item.edit_traits;
                document.getElementById('edit-traits-text').textContent = item.edit_traits;
                document.getElementById('edit-traits-display').classList.add('visible');
                document.getElementById('edit-traits-display').style.display = 'block';
            } else {
                editTraits = '';
                document.getElementById('edit-traits-display').classList.remove('visible');
                document.getElementById('edit-traits-display').style.display = 'none';
            }

            // Restore prompt (for image mode)
            imagePrompt = item.prompt || '';
            document.getElementById('prompt').value = imagePrompt;

            // Restore resolution
            if (item.resolution) {
                document.getElementById('resolution').value = item.resolution;
                currentResolution = item.resolution;
            } else {
                document.getElementById('resolution').value = 'auto';
                currentResolution = 'auto';
            }

            // Restore mode and update model options accordingly
            if (item.mode) {
                currentMode = item.mode.toLowerCase();
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === currentMode);
                });
                // Update model dropdown options based on mode (draft vs pro)
                updateModelOptions();
            }

            // Update quality dropdown visibility based on mode
            const qualitySection = document.getElementById('quality-section');
            if (currentMode === 'pro') {
                qualitySection.style.display = 'flex';
                // Restore quality if available
                if (item.quality) {
                    document.getElementById('quality').value = item.quality;
                    currentQuality = item.quality;
                }
            } else {
                qualitySection.style.display = 'none';
            }
            
            // Restore the specific model used (after updateModelOptions populates the dropdown)
            if (item.model) {
                currentModel = item.model;
                document.getElementById('model-select').value = item.model;
                updateModelParamsVisibility();
            }

            // If this was an Edit Mode + Brush image, restore to Edit Mode with mask
            if (item.input_mode === 'edit' && editDataUrl) {
                // Switch to Edit input mode
                currentInputMode = 'edit';
                document.querySelectorAll('.input-mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.inputMode === 'edit');
                });
                updateInputModeUI();
                
                // Clear any historyItems viewing state
                viewingHistoryId = null;
                
                // Show the full-quality edit image in the edit canvas (already fetched above)
                showEditCanvas(editDataUrl);
                
                // Fetch full-quality mask from GridFS if available
                let maskDataUrl = null;
                if (item.mask_gridfs_id) {
                    try {
                        const maskResponse = await fetch(`/api/image/${item.mask_gridfs_id}`);
                        const maskData = await maskResponse.json();
                        if (maskData.success && maskData.image) {
                            maskDataUrl = 'data:image/png;base64,' + maskData.image;
                            console.log('[VIEWR] Loaded full-quality mask from GridFS');
                        }
                    } catch (e) {
                        console.error('[VIEWR] Failed to fetch mask from GridFS:', e);
                    }
                }
                // Fallback to thumbnail if GridFS fetch failed
                if (!maskDataUrl && item.mask_image) {
                    maskDataUrl = item.mask_image.startsWith('data:') 
                        ? item.mask_image 
                        : 'data:image/png;base64,' + item.mask_image;
                }
                
                // Wait for canvas to be ready, then restore the mask
                if (maskDataUrl) {
                    // Use setTimeout to ensure canvas is ready after showEditCanvas
                    setTimeout(() => {
                        if (maskCanvas && maskCtx) {
                            const maskImg = new Image();
                            maskImg.onload = () => {
                                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                                maskCtx.drawImage(maskImg, 0, 0, maskCanvas.width, maskCanvas.height);
                                // Save this as the initial state for undo
                                undoStack = [];
                                redoStack = [];
                                saveCanvasState();
                                updateUndoRedoButtons();
                            };
                            maskImg.src = maskDataUrl;
                        }
                    }, 100);
                }
                
                // Hide the output image placeholder, show edit canvas
                document.getElementById('placeholder').style.display = 'none';
                document.getElementById('image-container').style.display = 'none';
                
                // Show canvas tools
                document.getElementById('canvas-tools').classList.add('visible');
            }
            
            // Restore reference attributes if available
            if (item.ref_attributes && Array.isArray(item.ref_attributes)) {
                selectedRefAttributes = item.ref_attributes;
                document.querySelectorAll('.ref-attr-btn').forEach(btn => {
                    btn.classList.toggle('active', selectedRefAttributes.includes(btn.dataset.attr));
                });
            }
            
            // Restore seed for Nano Banana Pro
            const seedInput = document.getElementById('nano-pro-seed');
            if (item.seed !== undefined && item.seed !== null) {
                nanoProSeed = item.seed;
                seedInput.value = item.seed;
                seedInput.classList.add('has-value');
            } else {
                nanoProSeed = null;
                seedInput.value = '';
                seedInput.classList.remove('has-value');
            }

            saveState();
        }

        async function recreateVideoFromItem(item) {
            console.log('[VIEWR] Recreating video from history item:', item);
            
            // Switch to Video mode
            document.querySelectorAll('.input-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.inputMode === 'video');
            });
            currentInputMode = 'video';
            updateInputModeUI();
            updateModelParamsVisibility();
            
            // Restore video model
            if (item.video_model) {
                currentVideoModel = item.video_model;
                document.getElementById('video-model-select').value = item.video_model;
                updateEndFrameAvailability();
                updateAudioToggleVisibility();
                updateModelParamsVisibility();
            }
            
            // Restore prompt (for video mode)
            videoPrompt = item.prompt || '';
            document.getElementById('prompt').value = videoPrompt;
            
            // Restore duration
            if (item.duration) {
                videoDuration = item.duration;
                document.getElementById('video-duration').value = item.duration;
            }
            
            // Restore aspect ratio
            if (item.aspect_ratio) {
                document.getElementById('resolution').value = item.aspect_ratio;
                currentResolution = item.aspect_ratio;
            }
            
            // Restore audio toggle
            if (item.audio_enabled !== undefined) {
                audioEnabled = item.audio_enabled;
                document.querySelectorAll('.audio-toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', 
                        (audioEnabled && btn.dataset.audio === 'on') || 
                        (!audioEnabled && btn.dataset.audio === 'off')
                    );
                });
            }
            
            // Restore negative prompt
            if (item.negative_prompt) {
                videoNegativePrompt = item.negative_prompt;
                document.getElementById('video-negative-prompt').value = item.negative_prompt;
            }
            
            // Restore CFG scale
            if (item.cfg_scale !== undefined) {
                videoCfgScale = item.cfg_scale;
                document.getElementById('video-cfg-scale').value = item.cfg_scale;
                document.getElementById('cfg-scale-value').textContent = item.cfg_scale.toFixed(1);
            }
            
            // Restore character orientation (for motion control models)
            if (item.character_orientation) {
                motionCharOrientation = item.character_orientation;
                document.getElementById('motion-char-orientation').value = item.character_orientation;
            }
            
            // Restore keep original sound (for motion control models)
            if (item.keep_original_sound !== undefined) {
                motionKeepOriginalSound = item.keep_original_sound;
                document.getElementById('keep-sound-off').classList.toggle('active', !motionKeepOriginalSound);
                document.getElementById('keep-sound-on').classList.toggle('active', motionKeepOriginalSound);
            }
            
            // Fetch and restore start frame from GridFS
            if (item.start_frame_gridfs_id) {
                try {
                    const response = await fetch(`/api/image/${item.start_frame_gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        startFrameImage = 'data:image/png;base64,' + data.image;
                        updateVideoFramePreview('start', startFrameImage);
                        console.log('[VIEWR] Restored start frame from GridFS');
                    }
                } catch (e) {
                    console.error('[VIEWR] Failed to fetch start frame from GridFS:', e);
                    // Fallback to thumbnail
                    if (item.start_frame_thumbnail) {
                        startFrameImage = 'data:image/jpeg;base64,' + item.start_frame_thumbnail;
                        updateVideoFramePreview('start', startFrameImage);
                    }
                }
            } else if (item.start_frame_thumbnail) {
                // Legacy: use thumbnail
                startFrameImage = 'data:image/jpeg;base64,' + item.start_frame_thumbnail;
                updateVideoFramePreview('start', startFrameImage);
            } else {
                startFrameImage = null;
                updateVideoFramePreview('start', null);
            }
            
            // Fetch and restore end frame from GridFS
            if (item.end_frame_gridfs_id) {
                try {
                    const response = await fetch(`/api/image/${item.end_frame_gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        endFrameImage = 'data:image/png;base64,' + data.image;
                        updateVideoFramePreview('end', endFrameImage);
                        console.log('[VIEWR] Restored end frame from GridFS');
                    }
                } catch (e) {
                    console.error('[VIEWR] Failed to fetch end frame from GridFS:', e);
                    // Fallback to thumbnail
                    if (item.end_frame_thumbnail) {
                        endFrameImage = 'data:image/jpeg;base64,' + item.end_frame_thumbnail;
                        updateVideoFramePreview('end', endFrameImage);
                    }
                }
            } else if (item.end_frame_thumbnail) {
                // Legacy: use thumbnail
                endFrameImage = 'data:image/jpeg;base64,' + item.end_frame_thumbnail;
                updateVideoFramePreview('end', endFrameImage);
            } else {
                endFrameImage = null;
                updateVideoFramePreview('end', null);
            }
            
            // Fetch and restore motion video from GridFS
            if (item.motion_video_gridfs_id) {
                try {
                    const response = await fetch(`/api/image/${item.motion_video_gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        motionVideoData = 'data:video/mp4;base64,' + data.image;
                        // Show motion video in the motion box
                        const motionBox = document.getElementById('motion-video-box');
                        if (motionBox) {
                            motionBox.innerHTML = `<video src="${motionVideoData}" class="motion-preview" muted loop autoplay></video>`;
                        }
                        console.log('[VIEWR] Restored motion video from GridFS');
                    }
                } catch (e) {
                    console.error('[VIEWR] Failed to fetch motion video from GridFS:', e);
                }
            } else {
                motionVideoData = null;
            }
            
            // Fetch and restore character references from GridFS
            const charRefGridfsIds = item.character_ref_gridfs_ids || [];
            const charRefThumbnails = item.character_ref_thumbnails || [];
            
            if (charRefGridfsIds.length > 0) {
                videoCharReferences = [];
                for (let i = 0; i < charRefGridfsIds.length; i++) {
                    try {
                        const response = await fetch(`/api/image/${charRefGridfsIds[i]}`);
                        const data = await response.json();
                        if (data.success && data.image) {
                            videoCharReferences.push({
                                id: 'restored_' + i + '_' + Date.now(),
                                dataUrl: 'data:image/png;base64,' + data.image,
                                traits: ''
                            });
                        }
                    } catch (e) {
                        console.error('[VIEWR] Failed to fetch character ref from GridFS:', e);
                        // Fallback to thumbnail
                        if (charRefThumbnails[i]) {
                            videoCharReferences.push({
                                id: 'restored_thumb_' + i + '_' + Date.now(),
                                dataUrl: 'data:image/jpeg;base64,' + charRefThumbnails[i],
                                traits: ''
                            });
                        }
                    }
                }
                renderVideoCharGrid();
                console.log('[VIEWR] Restored', videoCharReferences.length, 'character references');
            } else if (charRefThumbnails.length > 0) {
                // Legacy: use thumbnails
                videoCharReferences = charRefThumbnails.map((thumb, i) => ({
                    id: 'legacy_' + i + '_' + Date.now(),
                    dataUrl: 'data:image/jpeg;base64,' + thumb,
                    traits: ''
                }));
                renderVideoCharGrid();
            } else {
                videoCharReferences = [];
                renderVideoCharGrid();
            }
            
            saveState();
            console.log('[VIEWR] Video recreation complete - all parameters restored');
        }

        async function downloadImage(item) {
            // If item has gridfs_id, fetch full quality first
            let imageData = item.image || item;

            if (item.gridfs_id) {
                try {
                    console.log('[VIEWR] Fetching full-quality image for download...');
                    const response = await fetch(`/api/image/${item.gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        imageData = data.image;
                    }
                } catch (e) {
                    console.warn('[VIEWR] Could not fetch full-quality image for download:', e);
                }
            }

            const link = document.createElement('a');
            link.download = 'viewr_' + Date.now() + '.png';
            link.href = 'data:image/png;base64,' + imageData;
            link.click();
        }

        async function saveToSaved(item) {
            try {
                // Check if already saved (by gridfs_id, video_url, or image)
                const existingItem = saved.find(s =>
                    (s.gridfs_id && item.gridfs_id && s.gridfs_id === item.gridfs_id) ||
                    (s.video_url && item.video_url && s.video_url === item.video_url) ||
                    (s.image === item.image)
                );

                if (existingItem) {
                    // Unsave: remove from saved collection
                    const response = await fetch(`/api/saved/${existingItem.id}`, {
                        method: 'DELETE'
                    });
                    const data = await response.json();
                    if (data.success) {
                        await refreshSaved();
                        renderHistory();
                        updateStorageIndicator();
                    }
                } else {
                    // Save: add to saved collection
                    const response = await fetch('/api/saved', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(item)
                    });
                    const data = await response.json();
                    if (data.success) {
                        await refreshSaved();
                        renderHistory();
                        updateStorageIndicator();
                    }
                }
            } catch (e) {
                console.error('Failed to toggle save:', e);
            }
        }

        async function deleteItem(id, type) {
            try {
                // Optimistically update UI for instant feel
                if (type === 'history') {
                    historyItems = historyItems.filter(item => item.id !== id);
                    renderHistory();
                } else {
                    saved = saved.filter(item => item.id !== id);
                    renderSaved();
                }

                const endpoint = type === 'history' ? `/api/history/${id}` : `/api/saved/${id}`;
                const response = await fetch(endpoint, { method: 'DELETE' });
                const data = await response.json();

                if (data.success) {
                    // Update storage indicator after successful deletion
                    updateStorageIndicator();
                } else {
                    // Revert if server delete failed
                    console.error('Server delete failed, refreshing list');
                    if (type === 'historyItems') refreshHistory();
                    else refreshSaved();
                }
            } catch (e) {
                console.error('Failed to delete:', e);
                // Refresh list on error to ensure UI sync
                if (type === 'historyItems') refreshHistory();
                else refreshSaved();
            }
        }

        async function refreshSaved() {
            try {
                const response = await fetch('/api/saved');
                const data = await response.json();

                if (data.success) {
                    saved = data.saved;
                    renderSaved();
                }
            } catch (e) {
                console.warn('Failed to fetch saved from MongoDB:', e);
            }
        }

        function renderSaved() {
            const list = document.getElementById('saved-list');
            const empty = document.getElementById('saved-empty');

            // Always clear existing items first
            list.querySelectorAll('.history-item').forEach(el => el.remove());

            if (saved.length === 0) {
                empty.style.display = 'block';
                return;
            }

            empty.style.display = 'none';

            saved.forEach(item => {
                const div = createItemCard(item, 'saved');
                list.appendChild(div);
            });
        }

        async function clearSaved() {
            showModal(
                'CLEAR SAVED',
                'Are you sure you want to clear all saved images from the database? This cannot be undone.',
                async () => {
                    try {
                        const response = await fetch('/api/saved/clear', { method: 'POST' });
                        const data = await response.json();
                        if (data.success) {
                            saved = [];
                            renderSaved();
                            updateStorageIndicator();
                        }
                    } catch (e) {
                        console.error('Failed to clear saved:', e);
                    }
                }
            );
        }

        async function loadFromHistory(item) {
            const outputImage = document.getElementById('output-image');
            const imageContainer = document.getElementById('image-container');
            const placeholder = document.getElementById('placeholder');
            const downloadBtn = document.getElementById('download-btn');
            const zoomControls = document.getElementById('zoom-controls');
            const closeBtn = document.getElementById('close-output');
            const loading = document.getElementById('loading');

            // Switch to OUTPUT tab on mobile when viewing historyItems image
            if (isMobileView()) {
                switchMobilePanel('output');
            }

            // Track which item is being viewed
            viewingHistoryId = item.id;

            // Hide edit mode UI when viewing historyItems image
            const editCanvasContainer = document.getElementById('edit-canvas-container');
            const canvasTools = document.getElementById('canvas-tools');
            const mobileUndoRedo = document.getElementById('mobile-undo-redo');
            const undoRedoControls = document.getElementById('undo-redo-controls');
            editCanvasContainer.classList.remove('visible');
            canvasTools.classList.remove('visible');
            mobileUndoRedo.classList.remove('visible');
            undoRedoControls.classList.remove('visible');

            // Hide video prompt output when viewing historyItems image
            document.getElementById('video-prompt-output').classList.remove('visible');

            // Remove NEW badge if it was new
            if (newIds.has(item.id) || item.seen === false) {
                newIds.delete(item.id);
                // Update local item state IMMEDIATELY (before render)
                const historyItemsItem = historyItems.find(h => h.id === item.id);
                if (historyItemsItem) historyItemsItem.seen = true;
                // Also update the passed item reference
                item.seen = true;
                // Mark as seen in database (fire and forget)
                fetch(`/api/history/${item.id}/seen`, { method: 'POST' })
                    .catch(e => console.warn('Failed to mark as seen:', e));
                renderHistory();
            }

            // Hide loading if visible (user clicked while generating)
            loading.classList.remove('visible');

            // Hide and reset video container if visible
            const videoContainer = document.getElementById('video-container');
            const outputVideo = document.getElementById('output-video');
            if (videoContainer.style.display !== 'none') {
                outputVideo.pause();
                outputVideo.src = '';
                videoContainer.style.display = 'none';
            }

            // Show thumbnail immediately for fast feedback
            outputImage.src = 'data:image/png;base64,' + item.image;
            imageContainer.style.display = 'flex';
            placeholder.style.display = 'none';
            downloadBtn.classList.add('visible');
            zoomControls.classList.add('visible');
            closeBtn.classList.add('visible');

            // Reset zoom and offsets when loading from historyItems
            zoomLevel = 1;
            offsetX = 0;
            offsetY = 0;
            updateZoom();

            // If this item has a GridFS ID, fetch the full-quality image
            if (item.gridfs_id) {
                try {
                    console.log('[VIEWR] Fetching full-quality image from GridFS:', item.gridfs_id);
                    const response = await fetch(`/api/image/${item.gridfs_id}`);
                    const data = await response.json();
                    if (data.success && data.image) {
                        outputImage.src = 'data:image/png;base64,' + data.image;
                        console.log('[VIEWR] Full-quality image loaded');
                    }
                } catch (e) {
                    console.warn('[VIEWR] Could not fetch full-quality image:', e);
                }
            }
            // NOTE: Do NOT restore prompt here - only when recreate button is clicked
        }

        async function clearHistory() {
            showModal(
                'CLEAR HISTORY',
                'Are you sure you want to clear all generation historyItems from the database? This cannot be undone.',
                async () => {
                    try {
                        const response = await fetch('/api/history/clear', { method: 'POST' });
                        const data = await response.json();
                        if (data.success) {
                            historyItems = [];
                            renderHistory();
                            updateStorageIndicator();
                        }
                    } catch (e) {
                        console.error('Failed to clear historyItems:', e);
                    }
                }
            );
        }

        // Modal Logic
        let modalCallback = null;

        function showModal(title, text, callback) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-text').textContent = text;
            modalCallback = callback;
            document.getElementById('confirm-modal').classList.add('visible');
        }

        function closeModal() {
            document.getElementById('confirm-modal').classList.remove('visible');
            modalCallback = null;
        }

        document.getElementById('modal-confirm-btn').addEventListener('click', async () => {
            if (modalCallback) {
                await modalCallback();
            }
            closeModal();
        });

        // Lightbox functions
        function showLightbox(imageSrc) {
            const lightbox = document.getElementById('lightbox');
            const lightboxImage = document.getElementById('lightbox-image');
            lightboxImage.src = imageSrc;
            lightbox.classList.add('visible');
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            lightbox.classList.remove('visible');
        }

        document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
        document.getElementById('lightbox').addEventListener('click', (e) => {
            if (e.target === document.getElementById('lightbox')) {
                closeLightbox();
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Download (supports both images and videos)
        document.getElementById('download-btn').addEventListener('click', async () => {
            const img = document.getElementById('output-image');
            const video = document.getElementById('output-video');
            const videoContainer = document.getElementById('video-container');
            
            // Check if video is visible
            if (videoContainer && videoContainer.style.display !== 'none' && video.src) {
                // Download video
                try {
                    const response = await fetch(video.src);
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = 'viewr_video_' + Date.now() + '.mp4';
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                } catch (e) {
                    // Fallback: direct link
                    const link = document.createElement('a');
                    link.download = 'viewr_video_' + Date.now() + '.mp4';
                    link.href = video.src;
                    link.target = '_blank';
                    link.click();
                }
            } else if (img.src) {
                // Download image
                const link = document.createElement('a');
                link.download = 'viewr_' + Date.now() + '.png';
                link.href = img.src;
                link.click();
            }
        });

        // Error display
        function showError(msg) {
            const error = document.getElementById('error');
            error.textContent = msg;
            error.classList.add('visible');
            setTimeout(() => error.classList.remove('visible'), 5000);
        }
    </script>
</body>

</html>